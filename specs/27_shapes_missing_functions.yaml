# Missing Shapes Functions from API.MD
# Module: rshapes - Additional shape drawing and collision functions

functions:
  # === SHAPE TEXTURE FUNCTIONS ===
  - name: SETSHAPESTEXTURE
    raylib_name: SetShapesTexture
    args: [int, float, float, float, float]
    ret: void
    category: drawing
    description: "Set texture and rectangle to be used on shapes drawing"
    custom_body: |
      ::Rectangle source{(float)args[1].as_number(), (float)args[2].as_number(), (float)args[3].as_number(), (float)args[4].as_number()};
      ::SetShapesTexture(rlreg::textures.at(args[0].as_int()), source);
  
  - name: GETSHAPESTEXTURE
    raylib_name: GetShapesTexture
    args: []
    ret: int
    category: drawing
    description: "Get texture that is used for shapes drawing"
    custom_body: |
      ::Texture2D tex = ::GetShapesTexture();
      int id = rlreg::next_tex_id++;
      rlreg::textures[id] = tex;
      return Value::from_int(id);
  
  - name: GETSHAPESTEXTURERECTANGLE
    raylib_name: GetShapesTextureRectangle
    args: []
    ret: string
    category: drawing
    description: "Get texture source rectangle that is used for shapes drawing"
    custom_body: |
      ::Rectangle rec = ::GetShapesTextureRectangle();
      return Value::from_string(std::to_string(rec.x) + "," + std::to_string(rec.y) + "," + std::to_string(rec.width) + "," + std::to_string(rec.height));
  
  # === SHAPE DRAWING FUNCTIONS ===
  - name: DRAWLINESTRIP
    raylib_name: DrawLineStrip
    args: [string, int, int, int, int]
    ret: void
    category: drawing
    description: "Draw lines sequence (using gl lines) - points as comma-separated string"
    custom_body: |
      // TODO: Proper point array handling from string
  
  - name: DRAWCIRCLELINESV
    raylib_name: DrawCircleLinesV
    args: [float, float, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw circle outline (Vector version)"
    custom_body: |
      ::Vector2 center{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Color c{(unsigned char)args[3].as_int(), (unsigned char)args[4].as_int(), (unsigned char)args[5].as_int(), 255};
      ::DrawCircleLinesV(center, (float)args[2].as_number(), c);
  
  - name: DRAWRECTANGLEPRO
    raylib_name: DrawRectanglePro
    args: [float, float, float, float, float, float, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw a color-filled rectangle with pro parameters"
    custom_body: |
      ::Rectangle rec{(float)args[0].as_number(), (float)args[1].as_number(), (float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 origin{(float)args[4].as_number(), (float)args[5].as_number()};
      ::Color c{(unsigned char)args[7].as_int(), (unsigned char)args[8].as_int(), (unsigned char)args[9].as_int(), 255};
      ::DrawRectanglePro(rec, origin, (float)args[6].as_number(), c);
  
  - name: DRAWRECTANGLEGRADIENTV
    raylib_name: DrawRectangleGradientV
    args: [int, int, int, int, int, int, int, int, int, int]
    ret: void
    category: drawing
    description: "Draw a vertical-gradient-filled rectangle"
    custom_body: |
      ::Color top{(unsigned char)args[4].as_int(), (unsigned char)args[5].as_int(), (unsigned char)args[6].as_int(), 255};
      ::Color bottom{(unsigned char)args[7].as_int(), (unsigned char)args[8].as_int(), (unsigned char)args[9].as_int(), 255};
      ::DrawRectangleGradientV(args[0].as_int(), args[1].as_int(), args[2].as_int(), args[3].as_int(), top, bottom);
  
  - name: DRAWRECTANGLEGRADIENTH
    raylib_name: DrawRectangleGradientH
    args: [int, int, int, int, int, int, int, int, int, int]
    ret: void
    category: drawing
    description: "Draw a horizontal-gradient-filled rectangle"
    custom_body: |
      ::Color left{(unsigned char)args[4].as_int(), (unsigned char)args[5].as_int(), (unsigned char)args[6].as_int(), 255};
      ::Color right{(unsigned char)args[7].as_int(), (unsigned char)args[8].as_int(), (unsigned char)args[9].as_int(), 255};
      ::DrawRectangleGradientH(args[0].as_int(), args[1].as_int(), args[2].as_int(), args[3].as_int(), left, right);
  
  - name: DRAWRECTANGLEGRADIENTEX
    raylib_name: DrawRectangleGradientEx
    args: [float, float, float, float, int, int, int, int, int, int, int, int, int, int]
    ret: void
    category: drawing
    description: "Draw a gradient-filled rectangle with custom vertex colors"
    custom_body: |
      ::Rectangle rec{(float)args[0].as_number(), (float)args[1].as_number(), (float)args[2].as_number(), (float)args[3].as_number()};
      ::Color topLeft{(unsigned char)args[4].as_int(), (unsigned char)args[5].as_int(), (unsigned char)args[6].as_int(), 255};
      ::Color bottomLeft{(unsigned char)args[7].as_int(), (unsigned char)args[8].as_int(), (unsigned char)args[9].as_int(), 255};
      ::Color topRight{(unsigned char)args[10].as_int(), (unsigned char)args[11].as_int(), (unsigned char)args[12].as_int(), 255};
      ::Color bottomRight{(unsigned char)args[13].as_int(), (unsigned char)args[14].as_int(), (unsigned char)args[15].as_int(), 255};
      ::DrawRectangleGradientEx(rec, topLeft, bottomLeft, topRight, bottomRight);
  
  - name: DRAWRECTANGLEROUNDEDLINESEX
    raylib_name: DrawRectangleRoundedLinesEx
    args: [float, float, float, float, float, int, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw rectangle with rounded edges outline"
    custom_body: |
      ::Rectangle rec{(float)args[0].as_number(), (float)args[1].as_number(), (float)args[2].as_number(), (float)args[3].as_number()};
      ::Color c{(unsigned char)args[7].as_int(), (unsigned char)args[8].as_int(), (unsigned char)args[9].as_int(), 255};
      ::DrawRectangleRoundedLinesEx(rec, (float)args[4].as_number(), args[5].as_int(), (float)args[6].as_number(), c);
  
  # === SPLINE FUNCTIONS ===
  - name: DRAWSPLINELINEAR
    raylib_name: DrawSplineLinear
    args: [string, int, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw spline: Linear, minimum 2 points"
    custom_body: |
      // TODO: Proper point array handling
  
  - name: DRAWSPLINEBASIS
    raylib_name: DrawSplineBasis
    args: [string, int, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw spline: B-Spline, minimum 4 points"
    custom_body: |
      // TODO: Proper point array handling
  
  - name: DRAWSPLINECATMULLROM
    raylib_name: DrawSplineCatmullRom
    args: [string, int, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw spline: Catmull-Rom, minimum 4 points"
    custom_body: |
      // TODO: Proper point array handling
  
  - name: DRAWSPLINEBEZIERQUADRATIC
    raylib_name: DrawSplineBezierQuadratic
    args: [string, int, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw spline: Quadratic Bezier, minimum 3 points"
    custom_body: |
      // TODO: Proper point array handling
  
  - name: DRAWSPLINEBEZIERCUBIC
    raylib_name: DrawSplineBezierCubic
    args: [string, int, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw spline: Cubic Bezier, minimum 4 points"
    custom_body: |
      // TODO: Proper point array handling
  
  - name: DRAWSPLINESEGMENTLINEAR
    raylib_name: DrawSplineSegmentLinear
    args: [float, float, float, float, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw spline segment: Linear, 2 points"
    custom_body: |
      ::Vector2 p1{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 p2{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Color c{(unsigned char)args[5].as_int(), (unsigned char)args[6].as_int(), (unsigned char)args[7].as_int(), 255};
      ::DrawSplineSegmentLinear(p1, p2, (float)args[4].as_number(), c);
  
  - name: DRAWSPLINESEGMENTBASIS
    raylib_name: DrawSplineSegmentBasis
    args: [float, float, float, float, float, float, float, float, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw spline segment: B-Spline, 4 points"
    custom_body: |
      ::Vector2 p1{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 p2{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 p3{(float)args[4].as_number(), (float)args[5].as_number()};
      ::Vector2 p4{(float)args[6].as_number(), (float)args[7].as_number()};
      ::Color c{(unsigned char)args[9].as_int(), (unsigned char)args[10].as_int(), (unsigned char)args[11].as_int(), 255};
      ::DrawSplineSegmentBasis(p1, p2, p3, p4, (float)args[8].as_number(), c);
  
  - name: DRAWSPLINESEGMENTCATMULLROM
    raylib_name: DrawSplineSegmentCatmullRom
    args: [float, float, float, float, float, float, float, float, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw spline segment: Catmull-Rom, 4 points"
    custom_body: |
      ::Vector2 p1{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 p2{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 p3{(float)args[4].as_number(), (float)args[5].as_number()};
      ::Vector2 p4{(float)args[6].as_number(), (float)args[7].as_number()};
      ::Color c{(unsigned char)args[9].as_int(), (unsigned char)args[10].as_int(), (unsigned char)args[11].as_int(), 255};
      ::DrawSplineSegmentCatmullRom(p1, p2, p3, p4, (float)args[8].as_number(), c);
  
  - name: DRAWSPLINESEGMENTBEZIERQUADRATIC
    raylib_name: DrawSplineSegmentBezierQuadratic
    args: [float, float, float, float, float, float, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw spline segment: Quadratic Bezier, 2 points, 1 control point"
    custom_body: |
      ::Vector2 p1{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 c2{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 p3{(float)args[4].as_number(), (float)args[5].as_number()};
      ::Color c{(unsigned char)args[7].as_int(), (unsigned char)args[8].as_int(), (unsigned char)args[9].as_int(), 255};
      ::DrawSplineSegmentBezierQuadratic(p1, c2, p3, (float)args[6].as_number(), c);
  
  - name: DRAWSPLINESEGMENTBEZIERCUBIC
    raylib_name: DrawSplineSegmentBezierCubic
    args: [float, float, float, float, float, float, float, float, float, int, int, int]
    ret: void
    category: drawing
    description: "Draw spline segment: Cubic Bezier, 2 points, 2 control points"
    custom_body: |
      ::Vector2 p1{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 c2{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 c3{(float)args[4].as_number(), (float)args[5].as_number()};
      ::Vector2 p4{(float)args[6].as_number(), (float)args[7].as_number()};
      ::Color c{(unsigned char)args[9].as_int(), (unsigned char)args[10].as_int(), (unsigned char)args[11].as_int(), 255};
      ::DrawSplineSegmentBezierCubic(p1, c2, c3, p4, (float)args[8].as_number(), c);
  
  # === SPLINE POINT EVALUATION ===
  - name: GETSPLINEPOINTLINEAR
    raylib_name: GetSplinePointLinear
    args: [float, float, float, float, float]
    ret: string
    category: drawing
    description: "Get (evaluate) spline point: Linear"
    custom_body: |
      ::Vector2 start{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 end{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 point = ::GetSplinePointLinear(start, end, (float)args[4].as_number());
      return Value::from_string(std::to_string(point.x) + "," + std::to_string(point.y));
  
  - name: GETSPLINEPOINTBASIS
    raylib_name: GetSplinePointBasis
    args: [float, float, float, float, float, float, float, float, float]
    ret: string
    category: drawing
    description: "Get (evaluate) spline point: B-Spline"
    custom_body: |
      ::Vector2 p1{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 p2{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 p3{(float)args[4].as_number(), (float)args[5].as_number()};
      ::Vector2 p4{(float)args[6].as_number(), (float)args[7].as_number()};
      ::Vector2 point = ::GetSplinePointBasis(p1, p2, p3, p4, (float)args[8].as_number());
      return Value::from_string(std::to_string(point.x) + "," + std::to_string(point.y));
  
  - name: GETSPLINEPOINTCATMULLROM
    raylib_name: GetSplinePointCatmullRom
    args: [float, float, float, float, float, float, float, float, float]
    ret: string
    category: drawing
    description: "Get (evaluate) spline point: Catmull-Rom"
    custom_body: |
      ::Vector2 p1{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 p2{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 p3{(float)args[4].as_number(), (float)args[5].as_number()};
      ::Vector2 p4{(float)args[6].as_number(), (float)args[7].as_number()};
      ::Vector2 point = ::GetSplinePointCatmullRom(p1, p2, p3, p4, (float)args[8].as_number());
      return Value::from_string(std::to_string(point.x) + "," + std::to_string(point.y));
  
  - name: GETSPLINEPOINTBEZIERQUAD
    raylib_name: GetSplinePointBezierQuad
    args: [float, float, float, float, float, float, float]
    ret: string
    category: drawing
    description: "Get (evaluate) spline point: Quadratic Bezier"
    custom_body: |
      ::Vector2 p1{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 c2{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 p3{(float)args[4].as_number(), (float)args[5].as_number()};
      ::Vector2 point = ::GetSplinePointBezierQuad(p1, c2, p3, (float)args[6].as_number());
      return Value::from_string(std::to_string(point.x) + "," + std::to_string(point.y));
  
  - name: GETSPLINEPOINTBEZIERCUBIC
    raylib_name: GetSplinePointBezierCubic
    args: [float, float, float, float, float, float, float, float, float]
    ret: string
    category: drawing
    description: "Get (evaluate) spline point: Cubic Bezier"
    custom_body: |
      ::Vector2 p1{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 c2{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 c3{(float)args[4].as_number(), (float)args[5].as_number()};
      ::Vector2 p4{(float)args[6].as_number(), (float)args[7].as_number()};
      ::Vector2 point = ::GetSplinePointBezierCubic(p1, c2, c3, p4, (float)args[8].as_number());
      return Value::from_string(std::to_string(point.x) + "," + std::to_string(point.y));
  
  # === COLLISION FUNCTIONS ===
  - name: CHECKCOLLISIONCIRCLELINE
    raylib_name: CheckCollisionCircleLine
    args: [float, float, float, float, float, float, float]
    ret: bool
    category: collision
    description: "Check if circle collides with a line created between two points"
    custom_body: |
      ::Vector2 center{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 p1{(float)args[3].as_number(), (float)args[4].as_number()};
      ::Vector2 p2{(float)args[5].as_number(), (float)args[6].as_number()};
      return Value::from_bool(::CheckCollisionCircleLine(center, (float)args[2].as_number(), p1, p2));
  
  - name: CHECKCOLLISIONPOINTTRIANGLE
    raylib_name: CheckCollisionPointTriangle
    args: [float, float, float, float, float, float, float, float]
    ret: bool
    category: collision
    description: "Check if point is inside a triangle"
    custom_body: |
      ::Vector2 point{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 p1{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 p2{(float)args[4].as_number(), (float)args[5].as_number()};
      ::Vector2 p3{(float)args[6].as_number(), (float)args[7].as_number()};
      return Value::from_bool(::CheckCollisionPointTriangle(point, p1, p2, p3));
  
  - name: CHECKCOLLISIONPOINTLINE
    raylib_name: CheckCollisionPointLine
    args: [float, float, float, float, float, float, int]
    ret: bool
    category: collision
    description: "Check if point belongs to line created between two points with defined margin in pixels"
    custom_body: |
      ::Vector2 point{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 p1{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 p2{(float)args[4].as_number(), (float)args[5].as_number()};
      return Value::from_bool(::CheckCollisionPointLine(point, p1, p2, args[6].as_int()));
  
  - name: CHECKCOLLISIONPOINTPOLY
    raylib_name: CheckCollisionPointPoly
    args: [string, int]
    ret: bool
    category: collision
    description: "Check if point is within a polygon described by array of vertices"
    custom_body: |
      // TODO: Proper point array handling
      return Value::from_bool(false);
  
  - name: CHECKCOLLISIONLINES
    raylib_name: CheckCollisionLines
    args: [float, float, float, float, float, float, float, float]
    ret: string
    category: collision
    description: "Check the collision between two lines defined by two points each, returns collision point by reference"
    custom_body: |
      ::Vector2 start1{(float)args[0].as_number(), (float)args[1].as_number()};
      ::Vector2 end1{(float)args[2].as_number(), (float)args[3].as_number()};
      ::Vector2 start2{(float)args[4].as_number(), (float)args[5].as_number()};
      ::Vector2 end2{(float)args[6].as_number(), (float)args[7].as_number()};
      ::Vector2 collisionPoint;
      bool result = ::CheckCollisionLines(start1, end1, start2, end2, &collisionPoint);
      if (result) {
        return Value::from_string(std::to_string(collisionPoint.x) + "," + std::to_string(collisionPoint.y));
      }
      return Value::from_string("");
  
  - name: GETCOLLISIONREC
    raylib_name: GetCollisionRec
    args: [float, float, float, float, float, float, float, float]
    ret: string
    category: collision
    description: "Get collision rectangle for two rectangles collision"
    custom_body: |
      ::Rectangle rec1{(float)args[0].as_number(), (float)args[1].as_number(), (float)args[2].as_number(), (float)args[3].as_number()};
      ::Rectangle rec2{(float)args[4].as_number(), (float)args[5].as_number(), (float)args[6].as_number(), (float)args[7].as_number()};
      ::Rectangle collision = ::GetCollisionRec(rec1, rec2);
      return Value::from_string(std::to_string(collision.x) + "," + std::to_string(collision.y) + "," + std::to_string(collision.width) + "," + std::to_string(collision.height));

