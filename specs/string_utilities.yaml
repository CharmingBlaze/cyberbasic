functions:
  # === STRING & DATA UTILITIES ===
  - name: LEFT
    map_to: left
    args: [string, int]
    ret: string
    custom_body: |
      std::string text = args[0].as_string();
      int length = args[1].as_int();
      if (length <= 0) return Value::from_string("");
      if (length >= (int)text.length()) return Value::from_string(text);
      return Value::from_string(text.substr(0, length));
  
  - name: RIGHT
    map_to: right
    args: [string, int]
    ret: string
    custom_body: |
      std::string text = args[0].as_string();
      int length = args[1].as_int();
      if (length <= 0) return Value::from_string("");
      if (length >= (int)text.length()) return Value::from_string(text);
      return Value::from_string(text.substr(text.length() - length));
  
  - name: MID
    map_to: mid
    args: [string, int, int]
    ret: string
    custom_body: |
      std::string text = args[0].as_string();
      int start = args[1].as_int() - 1; // BASIC uses 1-based indexing
      int length = args[2].as_int();
      if (start < 0 || start >= (int)text.length() || length <= 0) return Value::from_string("");
      if (start + length > (int)text.length()) length = (int)text.length() - start;
      return Value::from_string(text.substr(start, length));
  
  - name: LEN
    map_to: len
    args: [string]
    ret: int
    custom_body: |
      return Value::from_int((int)args[0].as_string().length());
  
  - name: UCASE
    map_to: ucase
    args: [string]
    ret: string
    custom_body: |
      std::string text = args[0].as_string();
      std::transform(text.begin(), text.end(), text.begin(), ::toupper);
      return Value::from_string(text);
  
  - name: LCASE
    map_to: lcase
    args: [string]
    ret: string
    custom_body: |
      std::string text = args[0].as_string();
      std::transform(text.begin(), text.end(), text.begin(), ::tolower);
      return Value::from_string(text);
  
  - name: TRIM
    map_to: trim
    args: [string]
    ret: string
    custom_body: |
      std::string text = args[0].as_string();
      text.erase(0, text.find_first_not_of(" \t\r\n"));
      text.erase(text.find_last_not_of(" \t\r\n") + 1);
      return Value::from_string(text);
  
  - name: REPLACE
    map_to: replace
    args: [string, string, string]
    ret: string
    custom_body: |
      std::string text = args[0].as_string();
      std::string search = args[1].as_string();
      std::string replace = args[2].as_string();
      size_t pos = 0;
      while ((pos = text.find(search, pos)) != std::string::npos) {
        text.replace(pos, search.length(), replace);
        pos += replace.length();
      }
      return Value::from_string(text);
  
  - name: INSTR
    map_to: instr
    args: [string, string]
    ret: int
    custom_body: |
      std::string text = args[0].as_string();
      std::string search = args[1].as_string();
      size_t pos = text.find(search);
      if (pos == std::string::npos) return Value::from_int(0);
      return Value::from_int((int)pos + 1); // BASIC uses 1-based indexing
  
  - name: INSTRREV
    map_to: instrrev
    args: [string, string]
    ret: int
    custom_body: |
      std::string text = args[0].as_string();
      std::string search = args[1].as_string();
      size_t pos = text.rfind(search);
      if (pos == std::string::npos) return Value::from_int(0);
      return Value::from_int((int)pos + 1); // BASIC uses 1-based indexing
  
  - name: STRREPEAT
    map_to: strrepeat
    args: [string, int]
    ret: string
    custom_body: |
      std::string text = args[0].as_string();
      int count = args[1].as_int();
      std::string result;
      for (int i = 0; i < count; i++) {
        result += text;
      }
      return Value::from_string(result);
  
  - name: STRREVERSE
    map_to: strreverse
    args: [string]
    ret: string
    custom_body: |
      std::string text = args[0].as_string();
      std::reverse(text.begin(), text.end());
      return Value::from_string(text);
  
  - name: SPLIT
    map_to: split
    args: [string, string]
    ret: int
    custom_body: |
      // Simple split function - returns array index of first occurrence
      std::string text = args[0].as_string();
      std::string delimiter = args[1].as_string();
      size_t pos = text.find(delimiter);
      if (pos == std::string::npos) {
        return Value::from_int(-1); // Not found
      }
      return Value::from_int((int)pos);
  
  - name: ISNUMBER
    map_to: isnumber
    args: [string]
    ret: bool
    custom_body: |
      std::string text = args[0].as_string();
      if (text.empty()) return Value::from_bool(false);
      size_t pos = 0;
      if (text[0] == '+' || text[0] == '-') pos = 1;
      if (pos >= text.length()) return Value::from_bool(false);
      bool has_digit = false;
      bool has_dot = false;
      for (size_t i = pos; i < text.length(); i++) {
        if (text[i] >= '0' && text[i] <= '9') {
          has_digit = true;
        } else if (text[i] == '.' && !has_dot) {
          has_dot = true;
        } else {
          return Value::from_bool(false);
        }
      }
      return Value::from_bool(has_digit);
  
  - name: ISSTRING
    map_to: isstring
    args: [string]
    ret: bool
    custom_body: |
      // Always returns true for string arguments
      return Value::from_bool(true);
  
  - name: STR
    map_to: str
    args: [double]
    ret: string
    custom_body: |
      return Value::from_string(std::to_string(args[0].as_number()));
  
  - name: VAL
    map_to: val
    args: [string]
    ret: double
    custom_body: |
      try {
        return Value::from_number(std::stod(args[0].as_string()));
      } catch (...) {
        return Value::from_number(0.0);
      }
