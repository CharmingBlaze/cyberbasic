functions:
  # === COLLISION DETECTION SYSTEM ===
  - name: COLLISIONRECTANGLES
    map_to: collisionrectangles
    args: [int, int, int, int, int, int, int, int]
    ret: bool
    custom_body: |
      // Check collision between two rectangles
      int x1 = args[0].as_int();
      int y1 = args[1].as_int();
      int w1 = args[2].as_int();
      int h1 = args[3].as_int();
      int x2 = args[4].as_int();
      int y2 = args[5].as_int();
      int w2 = args[6].as_int();
      int h2 = args[7].as_int();
      
      bool collision = !(x1 + w1 < x2 || x2 + w2 < x1 || y1 + h1 < y2 || y2 + h2 < y1);
      return Value::from_bool(collision);
  
  - name: POINTINRECTANGLE
    map_to: pointinrectangle
    args: [int, int, int, int, int, int]
    ret: bool
    custom_body: |
      // Check if point is inside rectangle
      int px = args[0].as_int();
      int py = args[1].as_int();
      int rx = args[2].as_int();
      int ry = args[3].as_int();
      int rw = args[4].as_int();
      int rh = args[5].as_int();
      
      bool inside = (px >= rx && px <= rx + rw && py >= ry && py <= ry + rh);
      return Value::from_bool(inside);
  
  - name: POINTINCIRCLE
    map_to: pointincircle
    args: [int, int, int, int, int]
    ret: bool
    custom_body: |
      // Check if point is inside circle
      int px = args[0].as_int();
      int py = args[1].as_int();
      int cx = args[2].as_int();
      int cy = args[3].as_int();
      int radius = args[4].as_int();
      
      int dx = px - cx;
      int dy = py - cy;
      bool inside = (dx * dx + dy * dy) <= (radius * radius);
      return Value::from_bool(inside);
  
  - name: CIRCLEINRECTANGLE
    map_to: circleinrectangle
    args: [int, int, int, int, int, int, int]
    ret: bool
    custom_body: |
      // Check if circle is inside rectangle
      int cx = args[0].as_int();
      int cy = args[1].as_int();
      int radius = args[2].as_int();
      int rx = args[3].as_int();
      int ry = args[4].as_int();
      int rw = args[5].as_int();
      int rh = args[6].as_int();
      
      bool inside = (cx - radius >= rx && cx + radius <= rx + rw && 
                     cy - radius >= ry && cy + radius <= ry + rh);
      return Value::from_bool(inside);
  
  - name: CIRCLESOVERLAP
    map_to: circlesoverlap
    args: [int, int, int, int, int, int]
    ret: bool
    custom_body: |
      // Check if two circles overlap
      int x1 = args[0].as_int();
      int y1 = args[1].as_int();
      int r1 = args[2].as_int();
      int x2 = args[3].as_int();
      int y2 = args[4].as_int();
      int r2 = args[5].as_int();
      
      int dx = x2 - x1;
      int dy = y2 - y1;
      int distance_squared = dx * dx + dy * dy;
      int radius_sum = r1 + r2;
      bool overlap = distance_squared <= (radius_sum * radius_sum);
      return Value::from_bool(overlap);
  
  - name: RECTANGLEINRECTANGLE
    map_to: rectangleinrectangle
    args: [int, int, int, int, int, int, int, int]
    ret: bool
    custom_body: |
      // Check if one rectangle is completely inside another
      int x1 = args[0].as_int();
      int y1 = args[1].as_int();
      int w1 = args[2].as_int();
      int h1 = args[3].as_int();
      int x2 = args[4].as_int();
      int y2 = args[5].as_int();
      int w2 = args[6].as_int();
      int h2 = args[7].as_int();
      
      bool inside = (x1 >= x2 && y1 >= y2 && 
                     x1 + w1 <= x2 + w2 && y1 + h1 <= y2 + h2);
      return Value::from_bool(inside);
  
  - name: GETCOLLISIONRECTANGLE
    map_to: getcollisionrectangle
    args: [int, int, int, int, int, int, int, int]
    ret: string
    custom_body: |
      // Get the intersection rectangle between two rectangles
      int x1 = args[0].as_int();
      int y1 = args[1].as_int();
      int w1 = args[2].as_int();
      int h1 = args[3].as_int();
      int x2 = args[4].as_int();
      int y2 = args[5].as_int();
      int w2 = args[6].as_int();
      int h2 = args[7].as_int();
      
      int left = std::max(x1, x2);
      int top = std::max(y1, y2);
      int right = std::min(x1 + w1, x2 + w2);
      int bottom = std::min(y1 + h1, y2 + h2);
      
      if (left < right && top < bottom) {
        int width = right - left;
        int height = bottom - top;
        return Value::from_string(std::to_string(left) + "," + std::to_string(top) + "," + 
                                 std::to_string(width) + "," + std::to_string(height));
      } else {
        return Value::from_string("0,0,0,0"); // No intersection
      }
