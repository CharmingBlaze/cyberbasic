# Missing Raymath Functions from API.MD
# Module: raymath - Vector2, Vector3, Matrix, and Quaternion functions

functions:
  # === VECTOR2 FUNCTIONS ===
  - name: VECTOR2ZERO
    raylib_name: Vector2Zero
    args: []
    ret: string
    category: math
    description: "Vector with components value 0.0f"
    custom_body: |
      ::Vector2 v = ::Vector2Zero();
      return Value::from_string(std::to_string(v.x) + "," + std::to_string(v.y));

  - name: VECTOR2ONE
    raylib_name: Vector2One
    args: []
    ret: string
    category: math
    description: "Vector with components value 1.0f"
    custom_body: |
      ::Vector2 v = ::Vector2One();
      return Value::from_string(std::to_string(v.x) + "," + std::to_string(v.y));

  - name: VECTOR2ADD
    raylib_name: Vector2Add
    args: [float, float, float, float]
    ret: string
    category: math
    description: "Add two vectors (v1x, v1y, v2x, v2y)"
    custom_body: |
      ::Vector2 v1{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 v2{(float)FLOAT(2), (float)FLOAT(3)};
      ::Vector2 result = ::Vector2Add(v1, v2);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2ADDVALUE
    raylib_name: Vector2AddValue
    args: [float, float, float]
    ret: string
    category: math
    description: "Add vector and float value (vx, vy, add)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 result = ::Vector2AddValue(v, (float)FLOAT(2));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2SUBTRACT
    raylib_name: Vector2Subtract
    args: [float, float, float, float]
    ret: string
    category: math
    description: "Subtract two vectors (v1x, v1y, v2x, v2y)"
    custom_body: |
      ::Vector2 v1{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 v2{(float)FLOAT(2), (float)FLOAT(3)};
      ::Vector2 result = ::Vector2Subtract(v1, v2);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2SUBTRACTVALUE
    raylib_name: Vector2SubtractValue
    args: [float, float, float]
    ret: string
    category: math
    description: "Subtract vector by float value (vx, vy, sub)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 result = ::Vector2SubtractValue(v, (float)FLOAT(2));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2LENGTH
    raylib_name: Vector2Length
    args: [float, float]
    ret: float
    category: math
    description: "Calculate vector length (vx, vy)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      return Value::from_number(::Vector2Length(v));

  - name: VECTOR2LENGTHSQR
    raylib_name: Vector2LengthSqr
    args: [float, float]
    ret: float
    category: math
    description: "Calculate vector square length (vx, vy)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      return Value::from_number(::Vector2LengthSqr(v));

  - name: VECTOR2DOTPRODUCT
    raylib_name: Vector2DotProduct
    args: [float, float, float, float]
    ret: float
    category: math
    description: "Calculate two vectors dot product (v1x, v1y, v2x, v2y)"
    custom_body: |
      ::Vector2 v1{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 v2{(float)FLOAT(2), (float)FLOAT(3)};
      return Value::from_number(::Vector2DotProduct(v1, v2));

  - name: VECTOR2DISTANCE
    raylib_name: Vector2Distance
    args: [float, float, float, float]
    ret: float
    category: math
    description: "Calculate distance between two vectors (v1x, v1y, v2x, v2y)"
    custom_body: |
      ::Vector2 v1{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 v2{(float)FLOAT(2), (float)FLOAT(3)};
      return Value::from_number(::Vector2Distance(v1, v2));

  - name: VECTOR2DISTANCESQR
    raylib_name: Vector2DistanceSqr
    args: [float, float, float, float]
    ret: float
    category: math
    description: "Calculate square distance between two vectors (v1x, v1y, v2x, v2y)"
    custom_body: |
      ::Vector2 v1{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 v2{(float)FLOAT(2), (float)FLOAT(3)};
      return Value::from_number(::Vector2DistanceSqr(v1, v2));

  - name: VECTOR2ANGLE
    raylib_name: Vector2Angle
    args: [float, float, float, float]
    ret: float
    category: math
    description: "Calculate angle from two vectors (v1x, v1y, v2x, v2y)"
    custom_body: |
      ::Vector2 v1{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 v2{(float)FLOAT(2), (float)FLOAT(3)};
      return Value::from_number(::Vector2Angle(v1, v2));

  - name: VECTOR2SCALE
    raylib_name: Vector2Scale
    args: [float, float, float]
    ret: string
    category: math
    description: "Scale vector (multiply by value) (vx, vy, scale)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 result = ::Vector2Scale(v, (float)FLOAT(2));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2MULTIPLY
    raylib_name: Vector2Multiply
    args: [float, float, float, float]
    ret: string
    category: math
    description: "Multiply vector by vector (v1x, v1y, v2x, v2y)"
    custom_body: |
      ::Vector2 v1{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 v2{(float)FLOAT(2), (float)FLOAT(3)};
      ::Vector2 result = ::Vector2Multiply(v1, v2);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2NEGATE
    raylib_name: Vector2Negate
    args: [float, float]
    ret: string
    category: math
    description: "Negate vector (vx, vy)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 result = ::Vector2Negate(v);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2DIVIDE
    raylib_name: Vector2Divide
    args: [float, float, float, float]
    ret: string
    category: math
    description: "Divide vector by vector (v1x, v1y, v2x, v2y)"
    custom_body: |
      ::Vector2 v1{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 v2{(float)FLOAT(2), (float)FLOAT(3)};
      ::Vector2 result = ::Vector2Divide(v1, v2);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2NORMALIZE
    raylib_name: Vector2Normalize
    args: [float, float]
    ret: string
    category: math
    description: "Normalize provided vector (vx, vy)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 result = ::Vector2Normalize(v);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2LERP
    raylib_name: Vector2Lerp
    args: [float, float, float, float, float]
    ret: string
    category: math
    description: "Calculate linear interpolation between two vectors (v1x, v1y, v2x, v2y, amount)"
    custom_body: |
      ::Vector2 v1{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 v2{(float)FLOAT(2), (float)FLOAT(3)};
      ::Vector2 result = ::Vector2Lerp(v1, v2, (float)FLOAT(4));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2REFLECT
    raylib_name: Vector2Reflect
    args: [float, float, float, float]
    ret: string
    category: math
    description: "Calculate reflected vector to normal (vx, vy, normalX, normalY)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 normal{(float)FLOAT(2), (float)FLOAT(3)};
      ::Vector2 result = ::Vector2Reflect(v, normal);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2ROTATE
    raylib_name: Vector2Rotate
    args: [float, float, float]
    ret: string
    category: math
    description: "Rotate vector by angle (vx, vy, angle)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 result = ::Vector2Rotate(v, (float)FLOAT(2));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2MOVETOWARDS
    raylib_name: Vector2MoveTowards
    args: [float, float, float, float, float]
    ret: string
    category: math
    description: "Move Vector towards target (vx, vy, targetX, targetY, maxDistance)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 target{(float)FLOAT(2), (float)FLOAT(3)};
      ::Vector2 result = ::Vector2MoveTowards(v, target, (float)FLOAT(4));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2INVERT
    raylib_name: Vector2Invert
    args: [float, float]
    ret: string
    category: math
    description: "Invert the given vector (vx, vy)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 result = ::Vector2Invert(v);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2CLAMP
    raylib_name: Vector2Clamp
    args: [float, float, float, float, float, float]
    ret: string
    category: math
    description: "Clamp components between min and max (vx, vy, minX, minY, maxX, maxY)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 min{(float)FLOAT(2), (float)FLOAT(3)};
      ::Vector2 max{(float)FLOAT(4), (float)FLOAT(5)};
      ::Vector2 result = ::Vector2Clamp(v, min, max);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2CLAMPVALUE
    raylib_name: Vector2ClampValue
    args: [float, float, float, float]
    ret: string
    category: math
    description: "Clamp magnitude between two values (vx, vy, min, max)"
    custom_body: |
      ::Vector2 v{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 result = ::Vector2ClampValue(v, (float)FLOAT(2), (float)FLOAT(3));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y));

  - name: VECTOR2EQUALS
    raylib_name: Vector2Equals
    args: [float, float, float, float]
    ret: bool
    category: math
    description: "Check whether two vectors are almost equal (pX, pY, qX, qY)"
    custom_body: |
      ::Vector2 p{(float)FLOAT(0), (float)FLOAT(1)};
      ::Vector2 q{(float)FLOAT(2), (float)FLOAT(3)};
      return Value::from_bool(::Vector2Equals(p, q));

  # === VECTOR3 FUNCTIONS ===
  - name: VECTOR3ZERO
    raylib_name: Vector3Zero
    args: []
    ret: string
    category: math
    description: "Vector with components value 0.0f"
    custom_body: |
      ::Vector3 v = ::Vector3Zero();
      return Value::from_string(std::to_string(v.x) + "," + std::to_string(v.y) + "," + std::to_string(v.z));

  - name: VECTOR3ONE
    raylib_name: Vector3One
    args: []
    ret: string
    category: math
    description: "Vector with components value 1.0f"
    custom_body: |
      ::Vector3 v = ::Vector3One();
      return Value::from_string(std::to_string(v.x) + "," + std::to_string(v.y) + "," + std::to_string(v.z));

  - name: VECTOR3ADD
    raylib_name: Vector3Add
    args: [float, float, float, float, float, float]
    ret: string
    category: math
    description: "Add two vectors (v1x, v1y, v1z, v2x, v2y, v2z)"
    custom_body: |
      ::Vector3 v1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 v2{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 result = ::Vector3Add(v1, v2);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3ADDVALUE
    raylib_name: Vector3AddValue
    args: [float, float, float, float]
    ret: string
    category: math
    description: "Add vector and float value (vx, vy, vz, add)"
    custom_body: |
      ::Vector3 v{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 result = ::Vector3AddValue(v, (float)FLOAT(3));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3SUBTRACT
    raylib_name: Vector3Subtract
    args: [float, float, float, float, float, float]
    ret: string
    category: math
    description: "Subtract two vectors (v1x, v1y, v1z, v2x, v2y, v2z)"
    custom_body: |
      ::Vector3 v1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 v2{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 result = ::Vector3Subtract(v1, v2);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3SUBTRACTVALUE
    raylib_name: Vector3SubtractValue
    args: [float, float, float, float]
    ret: string
    category: math
    description: "Subtract vector by float value (vx, vy, vz, sub)"
    custom_body: |
      ::Vector3 v{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 result = ::Vector3SubtractValue(v, (float)FLOAT(3));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3SCALE
    raylib_name: Vector3Scale
    args: [float, float, float, float]
    ret: string
    category: math
    description: "Multiply vector by scalar (vx, vy, vz, scalar)"
    custom_body: |
      ::Vector3 v{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 result = ::Vector3Scale(v, (float)FLOAT(3));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3MULTIPLY
    raylib_name: Vector3Multiply
    args: [float, float, float, float, float, float]
    ret: string
    category: math
    description: "Multiply vector by vector (v1x, v1y, v1z, v2x, v2y, v2z)"
    custom_body: |
      ::Vector3 v1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 v2{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 result = ::Vector3Multiply(v1, v2);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3CROSSPRODUCT
    raylib_name: Vector3CrossProduct
    args: [float, float, float, float, float, float]
    ret: string
    category: math
    description: "Calculate two vectors cross product (v1x, v1y, v1z, v2x, v2y, v2z)"
    custom_body: |
      ::Vector3 v1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 v2{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 result = ::Vector3CrossProduct(v1, v2);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3LENGTH
    raylib_name: Vector3Length
    args: [float, float, float]
    ret: float
    category: math
    description: "Calculate vector length (vx, vy, vz)"
    custom_body: |
      ::Vector3 v{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      return Value::from_number(::Vector3Length(v));

  - name: VECTOR3LENGTHSQR
    raylib_name: Vector3LengthSqr
    args: [float, float, float]
    ret: float
    category: math
    description: "Calculate vector square length (vx, vy, vz)"
    custom_body: |
      ::Vector3 v{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      return Value::from_number(::Vector3LengthSqr(v));

  - name: VECTOR3DOTPRODUCT
    raylib_name: Vector3DotProduct
    args: [float, float, float, float, float, float]
    ret: float
    category: math
    description: "Calculate two vectors dot product (v1x, v1y, v1z, v2x, v2y, v2z)"
    custom_body: |
      ::Vector3 v1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 v2{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      return Value::from_number(::Vector3DotProduct(v1, v2));

  - name: VECTOR3DISTANCE
    raylib_name: Vector3Distance
    args: [float, float, float, float, float, float]
    ret: float
    category: math
    description: "Calculate distance between two vectors (v1x, v1y, v1z, v2x, v2y, v2z)"
    custom_body: |
      ::Vector3 v1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 v2{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      return Value::from_number(::Vector3Distance(v1, v2));

  - name: VECTOR3DISTANCESQR
    raylib_name: Vector3DistanceSqr
    args: [float, float, float, float, float, float]
    ret: float
    category: math
    description: "Calculate square distance between two vectors (v1x, v1y, v1z, v2x, v2y, v2z)"
    custom_body: |
      ::Vector3 v1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 v2{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      return Value::from_number(::Vector3DistanceSqr(v1, v2));

  - name: VECTOR3ANGLE
    raylib_name: Vector3Angle
    args: [float, float, float, float, float, float]
    ret: float
    category: math
    description: "Calculate angle between two vectors (v1x, v1y, v1z, v2x, v2y, v2z)"
    custom_body: |
      ::Vector3 v1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 v2{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      return Value::from_number(::Vector3Angle(v1, v2));

  - name: VECTOR3NEGATE
    raylib_name: Vector3Negate
    args: [float, float, float]
    ret: string
    category: math
    description: "Negate provided vector (vx, vy, vz)"
    custom_body: |
      ::Vector3 v{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 result = ::Vector3Negate(v);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3DIVIDE
    raylib_name: Vector3Divide
    args: [float, float, float, float, float, float]
    ret: string
    category: math
    description: "Divide vector by vector (v1x, v1y, v1z, v2x, v2y, v2z)"
    custom_body: |
      ::Vector3 v1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 v2{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 result = ::Vector3Divide(v1, v2);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3NORMALIZE
    raylib_name: Vector3Normalize
    args: [float, float, float]
    ret: string
    category: math
    description: "Normalize provided vector (vx, vy, vz)"
    custom_body: |
      ::Vector3 v{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 result = ::Vector3Normalize(v);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3LERP
    raylib_name: Vector3Lerp
    args: [float, float, float, float, float, float, float]
    ret: string
    category: math
    description: "Calculate linear interpolation between two vectors (v1x, v1y, v1z, v2x, v2y, v2z, amount)"
    custom_body: |
      ::Vector3 v1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 v2{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 result = ::Vector3Lerp(v1, v2, (float)FLOAT(6));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3REFLECT
    raylib_name: Vector3Reflect
    args: [float, float, float, float, float, float]
    ret: string
    category: math
    description: "Calculate reflected vector to normal (vx, vy, vz, normalX, normalY, normalZ)"
    custom_body: |
      ::Vector3 v{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 normal{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 result = ::Vector3Reflect(v, normal);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3MIN
    raylib_name: Vector3Min
    args: [float, float, float, float, float, float]
    ret: string
    category: math
    description: "Get min value for each pair of components (v1x, v1y, v1z, v2x, v2y, v2z)"
    custom_body: |
      ::Vector3 v1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 v2{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 result = ::Vector3Min(v1, v2);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3MAX
    raylib_name: Vector3Max
    args: [float, float, float, float, float, float]
    ret: string
    category: math
    description: "Get max value for each pair of components (v1x, v1y, v1z, v2x, v2y, v2z)"
    custom_body: |
      ::Vector3 v1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 v2{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 result = ::Vector3Max(v1, v2);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3INVERT
    raylib_name: Vector3Invert
    args: [float, float, float]
    ret: string
    category: math
    description: "Invert the given vector (vx, vy, vz)"
    custom_body: |
      ::Vector3 v{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 result = ::Vector3Invert(v);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3CLAMP
    raylib_name: Vector3Clamp
    args: [float, float, float, float, float, float, float, float, float]
    ret: string
    category: math
    description: "Clamp components between min and max (vx, vy, vz, minX, minY, minZ, maxX, maxY, maxZ)"
    custom_body: |
      ::Vector3 v{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 min{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 max{(float)FLOAT(6), (float)FLOAT(7), (float)FLOAT(8)};
      ::Vector3 result = ::Vector3Clamp(v, min, max);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3CLAMPVALUE
    raylib_name: Vector3ClampValue
    args: [float, float, float, float, float]
    ret: string
    category: math
    description: "Clamp magnitude between two values (vx, vy, vz, min, max)"
    custom_body: |
      ::Vector3 v{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 result = ::Vector3ClampValue(v, (float)FLOAT(3), (float)FLOAT(4));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  - name: VECTOR3EQUALS
    raylib_name: Vector3Equals
    args: [float, float, float, float, float, float]
    ret: bool
    category: math
    description: "Check whether two vectors are almost equal (pX, pY, pZ, qX, qY, qZ)"
    custom_body: |
      ::Vector3 p{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 q{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      return Value::from_bool(::Vector3Equals(p, q));

  - name: VECTOR3REFRACT
    raylib_name: Vector3Refract
    args: [float, float, float, float, float, float, float]
    ret: string
    category: math
    description: "Compute direction of refracted ray (vx, vy, vz, nX, nY, nZ, r)"
    custom_body: |
      ::Vector3 v{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 n{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 result = ::Vector3Refract(v, n, (float)FLOAT(6));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z));

  # === MATRIX FUNCTIONS ===
  - name: MATRIXIDENTITY
    raylib_name: MatrixIdentity
    args: []
    ret: string
    category: math
    description: "Get identity matrix"
    custom_body: |
      ::Matrix mat = MatrixIdentity();
      // Return as 16 comma-separated values
      return Value::from_string(std::to_string(mat.m0) + "," + std::to_string(mat.m1) + "," + std::to_string(mat.m2) + "," + std::to_string(mat.m3) + "," + std::to_string(mat.m4) + "," + std::to_string(mat.m5) + "," + std::to_string(mat.m6) + "," + std::to_string(mat.m7) + "," + std::to_string(mat.m8) + "," + std::to_string(mat.m9) + "," + std::to_string(mat.m10) + "," + std::to_string(mat.m11) + "," + std::to_string(mat.m12) + "," + std::to_string(mat.m13) + "," + std::to_string(mat.m14) + "," + std::to_string(mat.m15));

  - name: MATRIXTRANSLATE
    raylib_name: MatrixTranslate
    args: [float, float, float]
    ret: string
    category: math
    description: "Get translation matrix (x, y, z)"
    custom_body: |
      ::Matrix mat = ::MatrixTranslate((float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2));
      return Value::from_string(std::to_string(mat.m0) + "," + std::to_string(mat.m1) + "," + std::to_string(mat.m2) + "," + std::to_string(mat.m3) + "," + std::to_string(mat.m4) + "," + std::to_string(mat.m5) + "," + std::to_string(mat.m6) + "," + std::to_string(mat.m7) + "," + std::to_string(mat.m8) + "," + std::to_string(mat.m9) + "," + std::to_string(mat.m10) + "," + std::to_string(mat.m11) + "," + std::to_string(mat.m12) + "," + std::to_string(mat.m13) + "," + std::to_string(mat.m14) + "," + std::to_string(mat.m15));

  - name: MATRIXROTATEX
    raylib_name: MatrixRotateX
    args: [float]
    ret: string
    category: math
    description: "Get x-rotation matrix (angle)"
    custom_body: |
      ::Matrix mat = ::MatrixRotateX((float)FLOAT(0));
      return Value::from_string(std::to_string(mat.m0) + "," + std::to_string(mat.m1) + "," + std::to_string(mat.m2) + "," + std::to_string(mat.m3) + "," + std::to_string(mat.m4) + "," + std::to_string(mat.m5) + "," + std::to_string(mat.m6) + "," + std::to_string(mat.m7) + "," + std::to_string(mat.m8) + "," + std::to_string(mat.m9) + "," + std::to_string(mat.m10) + "," + std::to_string(mat.m11) + "," + std::to_string(mat.m12) + "," + std::to_string(mat.m13) + "," + std::to_string(mat.m14) + "," + std::to_string(mat.m15));

  - name: MATRIXROTATEY
    raylib_name: MatrixRotateY
    args: [float]
    ret: string
    category: math
    description: "Get y-rotation matrix (angle)"
    custom_body: |
      ::Matrix mat = ::MatrixRotateY((float)FLOAT(0));
      return Value::from_string(std::to_string(mat.m0) + "," + std::to_string(mat.m1) + "," + std::to_string(mat.m2) + "," + std::to_string(mat.m3) + "," + std::to_string(mat.m4) + "," + std::to_string(mat.m5) + "," + std::to_string(mat.m6) + "," + std::to_string(mat.m7) + "," + std::to_string(mat.m8) + "," + std::to_string(mat.m9) + "," + std::to_string(mat.m10) + "," + std::to_string(mat.m11) + "," + std::to_string(mat.m12) + "," + std::to_string(mat.m13) + "," + std::to_string(mat.m14) + "," + std::to_string(mat.m15));

  - name: MATRIXROTATEZ
    raylib_name: MatrixRotateZ
    args: [float]
    ret: string
    category: math
    description: "Get z-rotation matrix (angle)"
    custom_body: |
      ::Matrix mat = ::MatrixRotateZ((float)FLOAT(0));
      return Value::from_string(std::to_string(mat.m0) + "," + std::to_string(mat.m1) + "," + std::to_string(mat.m2) + "," + std::to_string(mat.m3) + "," + std::to_string(mat.m4) + "," + std::to_string(mat.m5) + "," + std::to_string(mat.m6) + "," + std::to_string(mat.m7) + "," + std::to_string(mat.m8) + "," + std::to_string(mat.m9) + "," + std::to_string(mat.m10) + "," + std::to_string(mat.m11) + "," + std::to_string(mat.m12) + "," + std::to_string(mat.m13) + "," + std::to_string(mat.m14) + "," + std::to_string(mat.m15));

  - name: MATRIXSCALE
    raylib_name: MatrixScale
    args: [float, float, float]
    ret: string
    category: math
    description: "Get scaling matrix (x, y, z)"
    custom_body: |
      ::Matrix mat = ::MatrixScale((float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2));
      return Value::from_string(std::to_string(mat.m0) + "," + std::to_string(mat.m1) + "," + std::to_string(mat.m2) + "," + std::to_string(mat.m3) + "," + std::to_string(mat.m4) + "," + std::to_string(mat.m5) + "," + std::to_string(mat.m6) + "," + std::to_string(mat.m7) + "," + std::to_string(mat.m8) + "," + std::to_string(mat.m9) + "," + std::to_string(mat.m10) + "," + std::to_string(mat.m11) + "," + std::to_string(mat.m12) + "," + std::to_string(mat.m13) + "," + std::to_string(mat.m14) + "," + std::to_string(mat.m15));

  # === QUATERNION FUNCTIONS ===
  - name: QUATERNIONIDENTITY
    raylib_name: QuaternionIdentity
    args: []
    ret: string
    category: math
    description: "Get identity quaternion"
    custom_body: |
      ::Quaternion q = ::QuaternionIdentity();
      return Value::from_string(std::to_string(q.x) + "," + std::to_string(q.y) + "," + std::to_string(q.z) + "," + std::to_string(q.w));

  - name: QUATERNIONLENGTH
    raylib_name: QuaternionLength
    args: [float, float, float, float]
    ret: float
    category: math
    description: "Compute length of quaternion (qx, qy, qz, qw)"
    custom_body: |
      ::Quaternion q{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2), (float)FLOAT(3)};
      return Value::from_number(::QuaternionLength(q));

  - name: QUATERNIONNORMALIZE
    raylib_name: QuaternionNormalize
    args: [float, float, float, float]
    ret: string
    category: math
    description: "Normalize provided quaternion (qx, qy, qz, qw)"
    custom_body: |
      ::Quaternion q{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2), (float)FLOAT(3)};
      ::Quaternion result = ::QuaternionNormalize(q);
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z) + "," + std::to_string(result.w));

  - name: QUATERNIONLERP
    raylib_name: QuaternionLerp
    args: [float, float, float, float, float, float, float, float, float]
    ret: string
    category: math
    description: "Calculate linear interpolation (q1x, q1y, q1z, q1w, q2x, q2y, q2z, q2w, amount)"
    custom_body: |
      ::Quaternion q1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2), (float)FLOAT(3)};
      ::Quaternion q2{(float)FLOAT(4), (float)FLOAT(5), (float)FLOAT(6), (float)FLOAT(7)};
      ::Quaternion result = ::QuaternionLerp(q1, q2, (float)FLOAT(8));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z) + "," + std::to_string(result.w));

  - name: QUATERNIONSLERP
    raylib_name: QuaternionSlerp
    args: [float, float, float, float, float, float, float, float, float]
    ret: string
    category: math
    description: "Calculate spherical linear interpolation (q1x, q1y, q1z, q1w, q2x, q2y, q2z, q2w, amount)"
    custom_body: |
      ::Quaternion q1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2), (float)FLOAT(3)};
      ::Quaternion q2{(float)FLOAT(4), (float)FLOAT(5), (float)FLOAT(6), (float)FLOAT(7)};
      ::Quaternion result = ::QuaternionSlerp(q1, q2, (float)FLOAT(8));
      return Value::from_string(std::to_string(result.x) + "," + std::to_string(result.y) + "," + std::to_string(result.z) + "," + std::to_string(result.w));

  - name: QUATERNIONFROMEULER
    raylib_name: QuaternionFromEuler
    args: [float, float, float]
    ret: string
    category: math
    description: "Get quaternion equivalent to Euler angles (pitch, yaw, roll)"
    custom_body: |
      ::Quaternion q = ::QuaternionFromEuler((float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2));
      return Value::from_string(std::to_string(q.x) + "," + std::to_string(q.y) + "," + std::to_string(q.z) + "," + std::to_string(q.w));

  - name: QUATERNIONTOEULER
    raylib_name: QuaternionToEuler
    args: [float, float, float, float]
    ret: string
    category: math
    description: "Get Euler angles equivalent to quaternion (qx, qy, qz, qw)"
    custom_body: |
      ::Quaternion q{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2), (float)FLOAT(3)};
      ::Vector3 euler = ::QuaternionToEuler(q);
      return Value::from_string(std::to_string(euler.x) + "," + std::to_string(euler.y) + "," + std::to_string(euler.z));
