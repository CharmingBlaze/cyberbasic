# Missing Textures/Images Functions from API.MD
# Module: rtextures - Additional texture and image functions

functions:
  # === IMAGE LOADING ===
  - name: LOADIMAGEANIMFROMMEMORY
    raylib_name: LoadImageAnimFromMemory
    args: [string, string, int]
    ret: image
    category: textures
    description: "Load image sequence from memory buffer (fileType, data, dataSize)"
    custom_body: |
      int frames;
      ::Image img = ::LoadImageAnimFromMemory(STR(0).c_str(), (const unsigned char*)STR(1).c_str(), INT(2), &frames);
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: LOADIMAGEFROMSCREEN
    raylib_name: LoadImageFromScreen
    args: []
    ret: image
    category: textures
    description: "Load image from screen buffer (screenshot)"
    custom_body: |
      ::Image img = ::LoadImageFromScreen();
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: ISIMAGEVALID
    raylib_name: IsImageValid
    args: [int]
    ret: bool
    category: textures
    description: "Check if image is valid"
    custom_body: |
      return Value::from_bool(::IsImageValid(rlreg::images.at(INT(0))));

  - name: EXPORTIMAGETOMEMORY
    raylib_name: ExportImageToMemory
    args: [int, string]
    ret: string
    category: textures
    description: "Export image to memory buffer (pass image ID, fileType)"
    custom_body: |
      int fileSize;
      unsigned char* data = ::ExportImageToMemory(rlreg::images.at(INT(0)), STR(1).c_str(), &fileSize);
      std::string result((char*)data, fileSize);
      ::MemFree(data);
      return Value::from_string(result);

  # === IMAGE GENERATION ===
  - name: GENIMAGEGRADIENTLINEAR
    raylib_name: GenImageGradientLinear
    args: [int, int, int, int, int, int, int, int, int]
    ret: image
    category: textures
    description: "Generate linear gradient image (width, height, direction, R1, G1, B1, R2, G2, B2)"
    custom_body: |
      ::Color start{(unsigned char)INT(3), (unsigned char)INT(4), (unsigned char)INT(5), 255};
      ::Color end{(unsigned char)INT(6), (unsigned char)INT(7), (unsigned char)INT(8), 255};
      ::Image img = ::GenImageGradientLinear(INT(0), INT(1), INT(2), start, end);
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: GENIMAGEGRADIENTRADIAL
    raylib_name: GenImageGradientRadial
    args: [int, int, float, int, int, int, int, int, int]
    ret: image
    category: textures
    description: "Generate radial gradient image (width, height, density, R1, G1, B1, R2, G2, B2)"
    custom_body: |
      ::Color inner{(unsigned char)INT(3), (unsigned char)INT(4), (unsigned char)INT(5), 255};
      ::Color outer{(unsigned char)INT(6), (unsigned char)INT(7), (unsigned char)INT(8), 255};
      ::Image img = ::GenImageGradientRadial(INT(0), INT(1), (float)FLOAT(2), inner, outer);
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: GENIMAGEGRADIENTSQUARE
    raylib_name: GenImageGradientSquare
    args: [int, int, float, int, int, int, int, int, int]
    ret: image
    category: textures
    description: "Generate square gradient image (width, height, density, R1, G1, B1, R2, G2, B2)"
    custom_body: |
      ::Color inner{(unsigned char)INT(3), (unsigned char)INT(4), (unsigned char)INT(5), 255};
      ::Color outer{(unsigned char)INT(6), (unsigned char)INT(7), (unsigned char)INT(8), 255};
      ::Image img = ::GenImageGradientSquare(INT(0), INT(1), (float)FLOAT(2), inner, outer);
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: GENIMAGECHECKED
    raylib_name: GenImageChecked
    args: [int, int, int, int, int, int, int, int, int, int]
    ret: image
    category: textures
    description: "Generate checked image (width, height, checksX, checksY, R1, G1, B1, R2, G2, B2)"
    custom_body: |
      ::Color col1{(unsigned char)INT(4), (unsigned char)INT(5), (unsigned char)INT(6), 255};
      ::Color col2{(unsigned char)INT(7), (unsigned char)INT(8), (unsigned char)INT(9), 255};
      ::Image img = ::GenImageChecked(INT(0), INT(1), INT(2), INT(3), col1, col2);
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: GENIMAGEWHITENOISE
    raylib_name: GenImageWhiteNoise
    args: [int, int, float]
    ret: image
    category: textures
    description: "Generate white noise image (width, height, factor)"
    custom_body: |
      ::Image img = ::GenImageWhiteNoise(INT(0), INT(1), (float)FLOAT(2));
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: GENIMAGEPERLINNOISE
    raylib_name: GenImagePerlinNoise
    args: [int, int, int, int, float]
    ret: image
    category: textures
    description: "Generate perlin noise image (width, height, offsetX, offsetY, scale)"
    custom_body: |
      ::Image img = ::GenImagePerlinNoise(INT(0), INT(1), INT(2), INT(3), (float)FLOAT(4));
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: GENIMAGECELLULAR
    raylib_name: GenImageCellular
    args: [int, int, int]
    ret: image
    category: textures
    description: "Generate cellular algorithm image (width, height, tileSize)"
    custom_body: |
      ::Image img = ::GenImageCellular(INT(0), INT(1), INT(2));
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: GENIMAGETEXT
    raylib_name: GenImageText
    args: [int, int, string]
    ret: image
    category: textures
    description: "Generate grayscale image from text (width, height, text)"
    custom_body: |
      ::Image img = ::GenImageText(INT(0), INT(1), STR(2).c_str());
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  # === IMAGE MANIPULATION ===
  - name: IMAGEFROMIMAGE
    raylib_name: ImageFromImage
    args: [int, float, float, float, float]
    ret: image
    category: textures
    description: "Create image from another image piece (pass image ID, x, y, width, height)"
    custom_body: |
      ::Rectangle rec{(float)FLOAT(1), (float)FLOAT(2), (float)FLOAT(3), (float)FLOAT(4)};
      ::Image img = ::ImageFromImage(rlreg::images.at(INT(0)), rec);
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: IMAGEFROMCHANNEL
    raylib_name: ImageFromChannel
    args: [int, int]
    ret: image
    category: textures
    description: "Create image from selected channel (pass image ID, selectedChannel)"
    custom_body: |
      ::Image img = ::ImageFromChannel(rlreg::images.at(INT(0)), INT(1));
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: IMAGETEXT
    raylib_name: ImageText
    args: [string, int, int, int, int]
    ret: image
    category: textures
    description: "Create image from text (default font) (text, fontSize, R, G, B)"
    custom_body: |
      ::Color color{(unsigned char)INT(2), (unsigned char)INT(3), (unsigned char)INT(4), 255};
      ::Image img = ::ImageText(STR(0).c_str(), INT(1), color);
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: IMAGETEXTEX
    raylib_name: ImageTextEx
    args: [int, string, float, float, int, int, int]
    ret: image
    category: textures
    description: "Create image from text (custom font) (pass font ID, text, fontSize, spacing, R, G, B)"
    custom_body: |
      ::Color tint{(unsigned char)INT(4), (unsigned char)INT(5), (unsigned char)INT(6), 255};
      ::Image img = ::ImageTextEx(rlreg::fonts.at(INT(0)), STR(1).c_str(), (float)FLOAT(2), (float)FLOAT(3), tint);
      int id = rlreg::next_image_id++;
      rlreg::images[id] = img;
      return Value::from_int(id);

  - name: IMAGEFORMAT
    raylib_name: ImageFormat
    args: [int, int]
    ret: void
    category: textures
    description: "Convert image data to desired format (pass image ID, newFormat)"
    custom_body: |
      ::ImageFormat(&rlreg::images.at(INT(0)), INT(1));

  - name: IMAGETOPOT
    raylib_name: ImageToPOT
    args: [int, int, int, int]
    ret: void
    category: textures
    description: "Convert image to POT (power-of-two) (pass image ID, R, G, B for fill)"
    custom_body: |
      ::Color fill{(unsigned char)INT(1), (unsigned char)INT(2), (unsigned char)INT(3), 255};
      ::ImageToPOT(&rlreg::images.at(INT(0)), fill);

  - name: IMAGEALPHACROP
    raylib_name: ImageAlphaCrop
    args: [int, float]
    ret: void
    category: textures
    description: "Crop image depending on alpha value (pass image ID, threshold)"
    custom_body: |
      ::ImageAlphaCrop(&rlreg::images.at(INT(0)), (float)FLOAT(1));

  - name: IMAGEALPHACLEAR
    raylib_name: ImageAlphaClear
    args: [int, int, int, int, float]
    ret: void
    category: textures
    description: "Clear alpha channel to desired color (pass image ID, R, G, B, threshold)"
    custom_body: |
      ::Color color{(unsigned char)INT(1), (unsigned char)INT(2), (unsigned char)INT(3), 255};
      ::ImageAlphaClear(&rlreg::images.at(INT(0)), color, (float)FLOAT(4));

  - name: IMAGEALPHAMASK
    raylib_name: ImageAlphaMask
    args: [int, int]
    ret: void
    category: textures
    description: "Apply alpha mask to image (pass image ID, alphaMask image ID)"
    custom_body: |
      ::ImageAlphaMask(&rlreg::images.at(INT(0)), rlreg::images.at(INT(1)));

  - name: IMAGEALPHAPREMULTIPLY
    raylib_name: ImageAlphaPremultiply
    args: [int]
    ret: void
    category: textures
    description: "Premultiply alpha channel (pass image ID)"
    custom_body: |
      ::ImageAlphaPremultiply(&rlreg::images.at(INT(0)));

  - name: IMAGEBLURGAUSSIAN
    raylib_name: ImageBlurGaussian
    args: [int, int]
    ret: void
    category: textures
    description: "Apply Gaussian blur (pass image ID, blurSize)"
    custom_body: |
      ::ImageBlurGaussian(&rlreg::images.at(INT(0)), INT(1));

  - name: IMAGEKERNELCONVOLUTION
    raylib_name: ImageKernelConvolution
    args: [int, string, int]
    ret: void
    category: textures
    description: "Apply custom convolution kernel (pass image ID, kernel as string, kernelSize)"
    custom_body: |
      // TODO: Proper kernel array handling

  - name: IMAGERESIZENN
    raylib_name: ImageResizeNN
    args: [int, int, int]
    ret: void
    category: textures
    description: "Resize image (Nearest-Neighbor) (pass image ID, newWidth, newHeight)"
    custom_body: |
      ::ImageResizeNN(&rlreg::images.at(INT(0)), INT(1), INT(2));

  - name: IMAGERESIZECANVAS
    raylib_name: ImageResizeCanvas
    args: [int, int, int, int, int, int, int, int]
    ret: void
    category: textures
    description: "Resize canvas and fill (pass image ID, newWidth, newHeight, offsetX, offsetY, R, G, B)"
    custom_body: |
      ::Color fill{(unsigned char)INT(5), (unsigned char)INT(6), (unsigned char)INT(7), 255};
      ::ImageResizeCanvas(&rlreg::images.at(INT(0)), INT(1), INT(2), INT(3), INT(4), fill);

  - name: IMAGEMIPMAPS
    raylib_name: ImageMipmaps
    args: [int]
    ret: void
    category: textures
    description: "Compute all mipmap levels (pass image ID)"
    custom_body: |
      ::ImageMipmaps(&rlreg::images.at(INT(0)));

  - name: IMAGEDITHER
    raylib_name: ImageDither
    args: [int, int, int, int, int]
    ret: void
    category: textures
    description: "Dither image data (pass image ID, rBpp, gBpp, bBpp, aBpp)"
    custom_body: |
      ::ImageDither(&rlreg::images.at(INT(0)), INT(1), INT(2), INT(3), INT(4));

  - name: IMAGEFLIPVERTICAL
    raylib_name: ImageFlipVertical
    args: [int]
    ret: void
    category: textures
    description: "Flip image vertically (pass image ID)"
    custom_body: |
      ::ImageFlipVertical(&rlreg::images.at(INT(0)));

  - name: IMAGEFLIPHORIZONTAL
    raylib_name: ImageFlipHorizontal
    args: [int]
    ret: void
    category: textures
    description: "Flip image horizontally (pass image ID)"
    custom_body: |
      ::ImageFlipHorizontal(&rlreg::images.at(INT(0)));

  - name: IMAGEROTATE
    raylib_name: ImageRotate
    args: [int, int]
    ret: void
    category: textures
    description: "Rotate image by angle (pass image ID, degrees)"
    custom_body: |
      ::ImageRotate(&rlreg::images.at(INT(0)), INT(1));

  - name: IMAGEROTATECW
    raylib_name: ImageRotateCW
    args: [int]
    ret: void
    category: textures
    description: "Rotate image clockwise 90deg (pass image ID)"
    custom_body: |
      ::ImageRotateCW(&rlreg::images.at(INT(0)));

  - name: IMAGEROTATECCW
    raylib_name: ImageRotateCCW
    args: [int]
    ret: void
    category: textures
    description: "Rotate image counter-clockwise 90deg (pass image ID)"
    custom_body: |
      ::ImageRotateCCW(&rlreg::images.at(INT(0)));

  - name: IMAGECOLORTINT
    raylib_name: ImageColorTint
    args: [int, int, int, int]
    ret: void
    category: textures
    description: "Modify image color: tint (pass image ID, R, G, B)"
    custom_body: |
      ::Color color{(unsigned char)INT(1), (unsigned char)INT(2), (unsigned char)INT(3), 255};
      ::ImageColorTint(&rlreg::images.at(INT(0)), color);

  - name: IMAGECOLORINVERT
    raylib_name: ImageColorInvert
    args: [int]
    ret: void
    category: textures
    description: "Modify image color: invert (pass image ID)"
    custom_body: |
      ::ImageColorInvert(&rlreg::images.at(INT(0)));

  - name: IMAGECOLORGRAYSCALE
    raylib_name: ImageColorGrayscale
    args: [int]
    ret: void
    category: textures
    description: "Modify image color: grayscale (pass image ID)"
    custom_body: |
      ::ImageColorGrayscale(&rlreg::images.at(INT(0)));

  - name: IMAGECOLORCONTRAST
    raylib_name: ImageColorContrast
    args: [int, float]
    ret: void
    category: textures
    description: "Modify image color: contrast (pass image ID, contrast)"
    custom_body: |
      ::ImageColorContrast(&rlreg::images.at(INT(0)), (float)FLOAT(1));

  - name: IMAGECOLORBRIGHTNESS
    raylib_name: ImageColorBrightness
    args: [int, int]
    ret: void
    category: textures
    description: "Modify image color: brightness (pass image ID, brightness)"
    custom_body: |
      ::ImageColorBrightness(&rlreg::images.at(INT(0)), INT(1));

  - name: IMAGECOLORREPLACE
    raylib_name: ImageColorReplace
    args: [int, int, int, int, int, int, int]
    ret: void
    category: textures
    description: "Modify image color: replace color (pass image ID, R1, G1, B1, R2, G2, B2)"
    custom_body: |
      ::Color color{(unsigned char)INT(1), (unsigned char)INT(2), (unsigned char)INT(3), 255};
      ::Color replace{(unsigned char)INT(4), (unsigned char)INT(5), (unsigned char)INT(6), 255};
      ::ImageColorReplace(&rlreg::images.at(INT(0)), color, replace);

  - name: GETIMAGEALPHABORDER
    raylib_name: GetImageAlphaBorder
    args: [int, float]
    ret: string
    category: textures
    description: "Get image alpha border rectangle (pass image ID, threshold)"
    custom_body: |
      ::Rectangle rec = ::GetImageAlphaBorder(rlreg::images.at(INT(0)), (float)FLOAT(1));
      return Value::from_string(std::to_string(rec.x) + "," + std::to_string(rec.y) + "," + std::to_string(rec.width) + "," + std::to_string(rec.height));

  - name: GETIMAGECOLOR
    raylib_name: GetImageColor
    args: [int, int, int]
    ret: string
    category: textures
    description: "Get image pixel color at position (pass image ID, x, y)"
    custom_body: |
      ::Color c = ::GetImageColor(rlreg::images.at(INT(0)), INT(1), INT(2));
      return Value::from_string(std::to_string(c.r) + "," + std::to_string(c.g) + "," + std::to_string(c.b) + "," + std::to_string(c.a));

  # === IMAGE DRAWING (CPU RENDERING) ===
  - name: IMAGECLEARBACKGROUND
    raylib_name: ImageClearBackground
    args: [int, int, int, int]
    ret: void
    category: textures
    description: "Clear image background (pass image ID, R, G, B)"
    custom_body: |
      ::Color color{(unsigned char)INT(1), (unsigned char)INT(2), (unsigned char)INT(3), 255};
      ::ImageClearBackground(&rlreg::images.at(INT(0)), color);

  - name: IMAGEDRAWPIXEL
    raylib_name: ImageDrawPixel
    args: [int, int, int, int, int, int]
    ret: void
    category: textures
    description: "Draw pixel within image (pass image ID, posX, posY, R, G, B)"
    custom_body: |
      ::Color color{(unsigned char)INT(3), (unsigned char)INT(4), (unsigned char)INT(5), 255};
      ::ImageDrawPixel(&rlreg::images.at(INT(0)), INT(1), INT(2), color);

  - name: IMAGEDRAWPIXELV
    raylib_name: ImageDrawPixelV
    args: [int, float, float, int, int, int]
    ret: void
    category: textures
    description: "Draw pixel within image (Vector version) (pass image ID, x, y, R, G, B)"
    custom_body: |
      ::Vector2 position{(float)FLOAT(1), (float)FLOAT(2)};
      ::Color color{(unsigned char)INT(3), (unsigned char)INT(4), (unsigned char)INT(5), 255};
      ::ImageDrawPixelV(&rlreg::images.at(INT(0)), position, color);

  - name: IMAGEDRAWLINE
    raylib_name: ImageDrawLine
    args: [int, int, int, int, int, int, int, int]
    ret: void
    category: textures
    description: "Draw line within image (pass image ID, startPosX, startPosY, endPosX, endPosY, R, G, B)"
    custom_body: |
      ::Color color{(unsigned char)INT(5), (unsigned char)INT(6), (unsigned char)INT(7), 255};
      ::ImageDrawLine(&rlreg::images.at(INT(0)), INT(1), INT(2), INT(3), INT(4), color);

  - name: IMAGEDRAWLINEV
    raylib_name: ImageDrawLineV
    args: [int, float, float, float, float, int, int, int]
    ret: void
    category: textures
    description: "Draw line within image (Vector version) (pass image ID, startX, startY, endX, endY, R, G, B)"
    custom_body: |
      ::Vector2 start{(float)FLOAT(1), (float)FLOAT(2)};
      ::Vector2 end{(float)FLOAT(3), (float)FLOAT(4)};
      ::Color color{(unsigned char)INT(5), (unsigned char)INT(6), (unsigned char)INT(7), 255};
      ::ImageDrawLineV(&rlreg::images.at(INT(0)), start, end, color);

  - name: IMAGEDRAWLINEEX
    raylib_name: ImageDrawLineEx
    args: [int, float, float, float, float, int, int, int, int]
    ret: void
    category: textures
    description: "Draw line with thickness within image (pass image ID, startX, startY, endX, endY, thick, R, G, B)"
    custom_body: |
      ::Vector2 start{(float)FLOAT(1), (float)FLOAT(2)};
      ::Vector2 end{(float)FLOAT(3), (float)FLOAT(4)};
      ::Color color{(unsigned char)INT(6), (unsigned char)INT(7), (unsigned char)INT(8), 255};
      ::ImageDrawLineEx(&rlreg::images.at(INT(0)), start, end, INT(5), color);

  - name: IMAGEDRAWCIRCLE
    raylib_name: ImageDrawCircle
    args: [int, int, int, int, int, int, int]
    ret: void
    category: textures
    description: "Draw filled circle within image (pass image ID, centerX, centerY, radius, R, G, B)"
    custom_body: |
      ::Color color{(unsigned char)INT(4), (unsigned char)INT(5), (unsigned char)INT(6), 255};
      ::ImageDrawCircle(&rlreg::images.at(INT(0)), INT(1), INT(2), INT(3), color);

  - name: IMAGEDRAWCIRCLEV
    raylib_name: ImageDrawCircleV
    args: [int, float, float, int, int, int, int]
    ret: void
    category: textures
    description: "Draw filled circle within image (Vector version) (pass image ID, centerX, centerY, radius, R, G, B)"
    custom_body: |
      ::Vector2 center{(float)FLOAT(1), (float)FLOAT(2)};
      ::Color color{(unsigned char)INT(4), (unsigned char)INT(5), (unsigned char)INT(6), 255};
      ::ImageDrawCircleV(&rlreg::images.at(INT(0)), center, INT(3), color);

  - name: IMAGEDRAWCIRCLELINES
    raylib_name: ImageDrawCircleLines
    args: [int, int, int, int, int, int, int]
    ret: void
    category: textures
    description: "Draw circle outline within image (pass image ID, centerX, centerY, radius, R, G, B)"
    custom_body: |
      ::Color color{(unsigned char)INT(4), (unsigned char)INT(5), (unsigned char)INT(6), 255};
      ::ImageDrawCircleLines(&rlreg::images.at(INT(0)), INT(1), INT(2), INT(3), color);

  - name: IMAGEDRAWCIRCLELINESV
    raylib_name: ImageDrawCircleLinesV
    args: [int, float, float, int, int, int, int]
    ret: void
    category: textures
    description: "Draw circle outline within image (Vector version) (pass image ID, centerX, centerY, radius, R, G, B)"
    custom_body: |
      ::Vector2 center{(float)FLOAT(1), (float)FLOAT(2)};
      ::Color color{(unsigned char)INT(4), (unsigned char)INT(5), (unsigned char)INT(6), 255};
      ::ImageDrawCircleLinesV(&rlreg::images.at(INT(0)), center, INT(3), color);

  - name: IMAGEDRAWRECTANGLE
    raylib_name: ImageDrawRectangle
    args: [int, int, int, int, int, int, int, int]
    ret: void
    category: textures
    description: "Draw rectangle within image (pass image ID, posX, posY, width, height, R, G, B)"
    custom_body: |
      ::Color color{(unsigned char)INT(5), (unsigned char)INT(6), (unsigned char)INT(7), 255};
      ::ImageDrawRectangle(&rlreg::images.at(INT(0)), INT(1), INT(2), INT(3), INT(4), color);

  - name: IMAGEDRAWRECTANGLEV
    raylib_name: ImageDrawRectangleV
    args: [int, float, float, float, float, int, int, int]
    ret: void
    category: textures
    description: "Draw rectangle within image (Vector version) (pass image ID, posX, posY, sizeX, sizeY, R, G, B)"
    custom_body: |
      ::Vector2 position{(float)FLOAT(1), (float)FLOAT(2)};
      ::Vector2 size{(float)FLOAT(3), (float)FLOAT(4)};
      ::Color color{(unsigned char)INT(5), (unsigned char)INT(6), (unsigned char)INT(7), 255};
      ::ImageDrawRectangleV(&rlreg::images.at(INT(0)), position, size, color);

  - name: IMAGEDRAWRECTANGLEREC
    raylib_name: ImageDrawRectangleRec
    args: [int, float, float, float, float, int, int, int]
    ret: void
    category: textures
    description: "Draw rectangle within image (pass image ID, x, y, width, height, R, G, B)"
    custom_body: |
      ::Rectangle rec{(float)FLOAT(1), (float)FLOAT(2), (float)FLOAT(3), (float)FLOAT(4)};
      ::Color color{(unsigned char)INT(5), (unsigned char)INT(6), (unsigned char)INT(7), 255};
      ::ImageDrawRectangleRec(&rlreg::images.at(INT(0)), rec, color);

  - name: IMAGEDRAWRECTANGLELINES
    raylib_name: ImageDrawRectangleLines
    args: [int, float, float, float, float, int, int, int, int]
    ret: void
    category: textures
    description: "Draw rectangle lines within image (pass image ID, x, y, width, height, thick, R, G, B)"
    custom_body: |
      ::Rectangle rec{(float)FLOAT(1), (float)FLOAT(2), (float)FLOAT(3), (float)FLOAT(4)};
      ::Color color{(unsigned char)INT(6), (unsigned char)INT(7), (unsigned char)INT(8), 255};
      ::ImageDrawRectangleLines(&rlreg::images.at(INT(0)), rec, INT(5), color);

  - name: IMAGEDRAWTRIANGLE
    raylib_name: ImageDrawTriangle
    args: [int, float, float, float, float, float, float, int, int, int]
    ret: void
    category: textures
    description: "Draw triangle within image (pass image ID, v1x, v1y, v2x, v2y, v3x, v3y, R, G, B)"
    custom_body: |
      ::Vector2 v1{(float)FLOAT(1), (float)FLOAT(2)};
      ::Vector2 v2{(float)FLOAT(3), (float)FLOAT(4)};
      ::Vector2 v3{(float)FLOAT(5), (float)FLOAT(6)};
      ::Color color{(unsigned char)INT(7), (unsigned char)INT(8), (unsigned char)INT(9), 255};
      ::ImageDrawTriangle(&rlreg::images.at(INT(0)), v1, v2, v3, color);

  - name: IMAGEDRAWTRIANGLEEX
    raylib_name: ImageDrawTriangleEx
    args: [int, float, float, float, float, float, float, int, int, int, int, int, int, int, int, int]
    ret: void
    category: textures
    description: "Draw triangle with interpolated colors (pass image ID, v1x, v1y, v2x, v2y, v3x, v3y, R1, G1, B1, R2, G2, B2, R3, G3, B3)"
    custom_body: |
      ::Vector2 v1{(float)FLOAT(1), (float)FLOAT(2)};
      ::Vector2 v2{(float)FLOAT(3), (float)FLOAT(4)};
      ::Vector2 v3{(float)FLOAT(5), (float)FLOAT(6)};
      ::Color c1{(unsigned char)INT(7), (unsigned char)INT(8), (unsigned char)INT(9), 255};
      ::Color c2{(unsigned char)INT(10), (unsigned char)INT(11), (unsigned char)INT(12), 255};
      ::Color c3{(unsigned char)INT(13), (unsigned char)INT(14), (unsigned char)INT(15), 255};
      ::ImageDrawTriangleEx(&rlreg::images.at(INT(0)), v1, v2, v3, c1, c2, c3);

  - name: IMAGEDRAWTRIANGLELINES
    raylib_name: ImageDrawTriangleLines
    args: [int, float, float, float, float, float, float, int, int, int]
    ret: void
    category: textures
    description: "Draw triangle outline within image (pass image ID, v1x, v1y, v2x, v2y, v3x, v3y, R, G, B)"
    custom_body: |
      ::Vector2 v1{(float)FLOAT(1), (float)FLOAT(2)};
      ::Vector2 v2{(float)FLOAT(3), (float)FLOAT(4)};
      ::Vector2 v3{(float)FLOAT(5), (float)FLOAT(6)};
      ::Color color{(unsigned char)INT(7), (unsigned char)INT(8), (unsigned char)INT(9), 255};
      ::ImageDrawTriangleLines(&rlreg::images.at(INT(0)), v1, v2, v3, color);

  - name: IMAGEDRAWTEXT
    raylib_name: ImageDrawText
    args: [int, string, int, int, int, int, int, int]
    ret: void
    category: textures
    description: "Draw text within image (default font) (pass image ID, text, posX, posY, fontSize, R, G, B)"
    custom_body: |
      ::Color color{(unsigned char)INT(4), (unsigned char)INT(5), (unsigned char)INT(6), 255};
      ::ImageDrawText(&rlreg::images.at(INT(0)), STR(1).c_str(), INT(2), INT(3), INT(4), color);

  - name: IMAGEDRAWTEXTEX
    raylib_name: ImageDrawTextEx
    args: [int, int, string, float, float, float, float, int, int, int]
    ret: void
    category: textures
    description: "Draw text within image (custom font) (pass image ID, font ID, text, posX, posY, fontSize, spacing, R, G, B)"
    custom_body: |
      ::Vector2 position{(float)FLOAT(3), (float)FLOAT(4)};
      ::Color tint{(unsigned char)INT(7), (unsigned char)INT(8), (unsigned char)INT(9), 255};
      ::ImageDrawTextEx(&rlreg::images.at(INT(0)), rlreg::fonts.at(INT(1)), STR(2).c_str(), position, (float)FLOAT(5), (float)FLOAT(6), tint);

  # === TEXTURE FUNCTIONS ===
  - name: LOADTEXTURECUBEMAP
    raylib_name: LoadTextureCubemap
    args: [int, int]
    ret: int
    category: textures
    description: "Load cubemap from image (pass image ID, layout)"
    custom_body: |
      ::Texture2D tex = ::LoadTextureCubemap(rlreg::images.at(INT(0)), INT(1));
      int id = rlreg::next_cubemap_id++;
      rlreg::cubemaps[id] = tex;
      return Value::from_int(id);

  - name: ISTEXTUREVALID
    raylib_name: IsTextureValid
    args: [int]
    ret: bool
    category: textures
    description: "Check if texture is valid (pass texture ID)"
    custom_body: |
      return Value::from_bool(::IsTextureValid(rlreg::textures.at(INT(0))));

  - name: ISRENDERTEXTUREVALID
    raylib_name: IsRenderTextureValid
    args: [int]
    ret: bool
    category: textures
    description: "Check if render texture is valid (pass render texture ID)"
    custom_body: |
      return Value::from_bool(::IsRenderTextureValid(rlreg::rendertextures.at(INT(0))));

  - name: UPDATETEXTUREREC
    raylib_name: UpdateTextureRec
    args: [int, float, float, float, float, string]
    ret: void
    category: textures
    description: "Update GPU texture rectangle (pass texture ID, x, y, width, height, pixels as string)"
    custom_body: |
      ::Rectangle rec{(float)FLOAT(1), (float)FLOAT(2), (float)FLOAT(3), (float)FLOAT(4)};
      (void)rec; // Suppress unused variable warning
      // TODO: Proper pixel data handling

  # === COLOR FUNCTIONS ===
  - name: COLORISEQUAL
    raylib_name: ColorIsEqual
    args: [int, int, int, int, int, int]
    ret: bool
    category: colors
    description: "Check if two colors are equal (R1, G1, B1, R2, G2, B2)"
    custom_body: |
      ::Color col1{(unsigned char)INT(0), (unsigned char)INT(1), (unsigned char)INT(2), 255};
      ::Color col2{(unsigned char)INT(3), (unsigned char)INT(4), (unsigned char)INT(5), 255};
      return Value::from_bool(::ColorIsEqual(col1, col2));

  - name: COLORTOINT
    raylib_name: ColorToInt
    args: [int, int, int]
    ret: int
    category: colors
    description: "Get hexadecimal value for Color (R, G, B)"
    custom_body: |
      ::Color color{(unsigned char)INT(0), (unsigned char)INT(1), (unsigned char)INT(2), 255};
      return Value::from_int(::ColorToInt(color));

  - name: COLORNORMALIZE
    raylib_name: ColorNormalize
    args: [int, int, int]
    ret: string
    category: colors
    description: "Get Color normalized as float [0..1] (R, G, B)"
    custom_body: |
      ::Color color{(unsigned char)INT(0), (unsigned char)INT(1), (unsigned char)INT(2), 255};
      ::Vector4 normalized = ::ColorNormalize(color);
      return Value::from_string(std::to_string(normalized.x) + "," + std::to_string(normalized.y) + "," + std::to_string(normalized.z) + "," + std::to_string(normalized.w));

  - name: COLORFROMNORMALIZED
    raylib_name: ColorFromNormalized
    args: [float, float, float, float]
    ret: string
    category: colors
    description: "Get Color from normalized values (x, y, z, w)"
    custom_body: |
      ::Vector4 normalized{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2), (float)FLOAT(3)};
      ::Color color = ::ColorFromNormalized(normalized);
      return Value::from_string(std::to_string(color.r) + "," + std::to_string(color.g) + "," + std::to_string(color.b) + "," + std::to_string(color.a));

  - name: COLORTOHSV
    raylib_name: ColorToHSV
    args: [int, int, int]
    ret: string
    category: colors
    description: "Get HSV values for Color (R, G, B)"
    custom_body: |
      ::Color color{(unsigned char)INT(0), (unsigned char)INT(1), (unsigned char)INT(2), 255};
      ::Vector3 hsv = ::ColorToHSV(color);
      return Value::from_string(std::to_string(hsv.x) + "," + std::to_string(hsv.y) + "," + std::to_string(hsv.z));

  - name: COLORFROMHSV
    raylib_name: ColorFromHSV
    args: [float, float, float]
    ret: string
    category: colors
    description: "Get Color from HSV values (hue, saturation, value)"
    custom_body: |
      ::Color color = ::ColorFromHSV((float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2));
      return Value::from_string(std::to_string(color.r) + "," + std::to_string(color.g) + "," + std::to_string(color.b) + "," + std::to_string(color.a));

  - name: COLORTINT
    raylib_name: ColorTint
    args: [int, int, int, int, int, int]
    ret: string
    category: colors
    description: "Get color multiplied with another color (R1, G1, B1, R2, G2, B2)"
    custom_body: |
      ::Color color{(unsigned char)INT(0), (unsigned char)INT(1), (unsigned char)INT(2), 255};
      ::Color tint{(unsigned char)INT(3), (unsigned char)INT(4), (unsigned char)INT(5), 255};
      ::Color result = ::ColorTint(color, tint);
      return Value::from_string(std::to_string(result.r) + "," + std::to_string(result.g) + "," + std::to_string(result.b) + "," + std::to_string(result.a));

  - name: COLORBRIGHTNESS
    raylib_name: ColorBrightness
    args: [int, int, int, float]
    ret: string
    category: colors
    description: "Get color with brightness correction (R, G, B, factor)"
    custom_body: |
      ::Color color{(unsigned char)INT(0), (unsigned char)INT(1), (unsigned char)INT(2), 255};
      ::Color result = ::ColorBrightness(color, (float)FLOAT(3));
      return Value::from_string(std::to_string(result.r) + "," + std::to_string(result.g) + "," + std::to_string(result.b) + "," + std::to_string(result.a));

  - name: COLORCONTRAST
    raylib_name: ColorContrast
    args: [int, int, int, float]
    ret: string
    category: colors
    description: "Get color with contrast correction (R, G, B, contrast)"
    custom_body: |
      ::Color color{(unsigned char)INT(0), (unsigned char)INT(1), (unsigned char)INT(2), 255};
      ::Color result = ::ColorContrast(color, (float)FLOAT(3));
      return Value::from_string(std::to_string(result.r) + "," + std::to_string(result.g) + "," + std::to_string(result.b) + "," + std::to_string(result.a));

  - name: COLORALPHA
    raylib_name: ColorAlpha
    args: [int, int, int, float]
    ret: string
    category: colors
    description: "Get color with alpha applied (R, G, B, alpha)"
    custom_body: |
      ::Color color{(unsigned char)INT(0), (unsigned char)INT(1), (unsigned char)INT(2), 255};
      ::Color result = ::ColorAlpha(color, (float)FLOAT(3));
      return Value::from_string(std::to_string(result.r) + "," + std::to_string(result.g) + "," + std::to_string(result.b) + "," + std::to_string(result.a));

  - name: COLORALPHABLEND
    raylib_name: ColorAlphaBlend
    args: [int, int, int, int, int, int, int, int, int]
    ret: string
    category: colors
    description: "Get src alpha-blended into dst color (R1, G1, B1, R2, G2, B2, R3, G3, B3)"
    custom_body: |
      ::Color dst{(unsigned char)INT(0), (unsigned char)INT(1), (unsigned char)INT(2), 255};
      ::Color src{(unsigned char)INT(3), (unsigned char)INT(4), (unsigned char)INT(5), 255};
      ::Color tint{(unsigned char)INT(6), (unsigned char)INT(7), (unsigned char)INT(8), 255};
      ::Color result = ::ColorAlphaBlend(dst, src, tint);
      return Value::from_string(std::to_string(result.r) + "," + std::to_string(result.g) + "," + std::to_string(result.b) + "," + std::to_string(result.a));

  - name: COLORLERP
    raylib_name: ColorLerp
    args: [int, int, int, int, int, int, float]
    ret: string
    category: colors
    description: "Get color lerp interpolation (R1, G1, B1, R2, G2, B2, factor)"
    custom_body: |
      ::Color color1{(unsigned char)INT(0), (unsigned char)INT(1), (unsigned char)INT(2), 255};
      ::Color color2{(unsigned char)INT(3), (unsigned char)INT(4), (unsigned char)INT(5), 255};
      ::Color result = ::ColorLerp(color1, color2, (float)FLOAT(6));
      return Value::from_string(std::to_string(result.r) + "," + std::to_string(result.g) + "," + std::to_string(result.b) + "," + std::to_string(result.a));

  - name: GETCOLOR
    raylib_name: GetColor
    args: [int]
    ret: string
    category: colors
    description: "Get Color structure from hexadecimal value"
    custom_body: |
      ::Color color = ::GetColor(INT(0));
      return Value::from_string(std::to_string(color.r) + "," + std::to_string(color.g) + "," + std::to_string(color.b) + "," + std::to_string(color.a));

  - name: GETPIXELDATASIZE
    raylib_name: GetPixelDataSize
    args: [int, int, int]
    ret: int
    category: colors
    description: "Get pixel data size in bytes (width, height, format)"
