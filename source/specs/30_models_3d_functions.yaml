# Missing 3D Models Functions from API.MD
# Module: rmodels - Additional 3D model, mesh, material, and animation functions

functions:
  # === 3D DRAWING ===
  - name: DRAWCAPSULE
    raylib_name: DrawCapsule
    args: [float, float, float, float, float, float, float, int, int, int, int, int]
    ret: void
    category: 3d
    description: "Draw capsule (startX, startY, startZ, endX, endY, endZ, radius, slices, rings, R, G, B)"
    custom_body: |
      ::Vector3 startPos{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 endPos{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Color color{(unsigned char)INT(9), (unsigned char)INT(10), (unsigned char)INT(11), 255};
      ::DrawCapsule(startPos, endPos, (float)FLOAT(6), INT(7), INT(8), color);

  - name: DRAWCAPSULEWIRES
    raylib_name: DrawCapsuleWires
    args: [float, float, float, float, float, float, float, int, int, int, int, int]
    ret: void
    category: 3d
    description: "Draw capsule wireframe (startX, startY, startZ, endX, endY, endZ, radius, slices, rings, R, G, B)"
    custom_body: |
      ::Vector3 startPos{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 endPos{(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Color color{(unsigned char)INT(9), (unsigned char)INT(10), (unsigned char)INT(11), 255};
      ::DrawCapsuleWires(startPos, endPos, (float)FLOAT(6), INT(7), INT(8), color);

  - name: DRAWMODELPOINTS
    raylib_name: DrawModelPoints
    args: [int, float, float, float, float, int, int, int]
    ret: void
    category: 3d
    description: "Draw model as points (pass model ID, x, y, z, scale, R, G, B)"
    custom_body: |
      ::Vector3 position{(float)FLOAT(1), (float)FLOAT(2), (float)FLOAT(3)};
      ::Color tint{(unsigned char)INT(5), (unsigned char)INT(6), (unsigned char)INT(7), 255};
      ::DrawModelPoints(rlreg::models.at(INT(0)), position, (float)FLOAT(4), tint);

  - name: DRAWMODELPOINTSEX
    raylib_name: DrawModelPointsEx
    args: [int, float, float, float, float, float, float, float, float, float, float, int, int, int]
    ret: void
    category: 3d
    description: "Draw model as points with extended parameters (pass model ID, x, y, z, rotAxisX, rotAxisY, rotAxisZ, rotAngle, scaleX, scaleY, scaleZ, R, G, B)"
    custom_body: |
      ::Vector3 position{(float)FLOAT(1), (float)FLOAT(2), (float)FLOAT(3)};
      ::Vector3 rotationAxis{(float)FLOAT(4), (float)FLOAT(5), (float)FLOAT(6)};
      ::Vector3 scale{(float)FLOAT(8), (float)FLOAT(9), (float)FLOAT(10)};
      ::Color tint{(unsigned char)INT(11), (unsigned char)INT(12), (unsigned char)INT(13), 255};
      ::DrawModelPointsEx(rlreg::models.at(INT(0)), position, rotationAxis, (float)FLOAT(7), scale, tint);

  - name: DRAWBILLBOARD
    raylib_name: DrawBillboard
    args: [int, int, float, float, float, float, int, int, int]
    ret: void
    category: 3d
    description: "Draw billboard texture (pass camera ID, texture ID, x, y, z, scale, R, G, B)"
    custom_body: |
      // TODO: Camera handling
      ::Vector3 position{(float)FLOAT(2), (float)FLOAT(3), (float)FLOAT(4)};
      ::Color tint{(unsigned char)INT(6), (unsigned char)INT(7), (unsigned char)INT(8), 255};
      (void)position; (void)tint; // Suppress unused variable warnings
      // ::DrawBillboard(camera, rlreg::textures.at(INT(1)), position, (float)FLOAT(5), tint);

  - name: DRAWBILLBOARDREC
    raylib_name: DrawBillboardRec
    args: [int, int, float, float, float, float, float, float, float, float, int, int, int]
    ret: void
    category: 3d
    description: "Draw billboard texture defined by source (pass camera ID, texture ID, x, y, z, sizeX, sizeY, R, G, B)"
    custom_body: |
      // TODO: Camera and Rectangle handling

  - name: DRAWBILLBOARDPRO
    raylib_name: DrawBillboardPro
    args: [int, int, float, float, float, float, float, float, float, float, float, float, float, float, float, int, int, int]
    ret: void
    category: 3d
    description: "Draw billboard texture with rotation (pass camera ID, texture ID, x, y, z, upX, upY, upZ, sizeX, sizeY, originX, originY, rotation, R, G, B)"
    custom_body: |
      // TODO: Camera handling

  # === MODEL FUNCTIONS ===
  - name: ISMODELVALID
    raylib_name: IsModelValid
    args: [int]
    ret: bool
    category: 3d
    description: "Check if model is valid (pass model ID)"
    custom_body: |
      return Value::from_bool(::IsModelValid(rlreg::models.at(INT(0))));

  - name: GETMODELBOUNDINGBOX
    raylib_name: GetModelBoundingBox
    args: [int]
    ret: string
    category: 3d
    description: "Compute model bounding box limits (pass model ID)"
    custom_body: |
      ::BoundingBox box = ::GetModelBoundingBox(rlreg::models.at(INT(0)));
      return Value::from_string(std::to_string(box.min.x) + "," + std::to_string(box.min.y) + "," + std::to_string(box.min.z) + "," + std::to_string(box.max.x) + "," + std::to_string(box.max.y) + "," + std::to_string(box.max.z));

  # === MESH FUNCTIONS ===
  - name: UPLOADMESH
    raylib_name: UploadMesh
    args: [int, bool]
    ret: void
    category: 3d
    description: "Upload mesh vertex data in GPU (pass mesh ID, dynamic)"
    custom_body: |
      ::UploadMesh(&rlreg::meshes.at(INT(0)), BOOL(1));

  - name: UPDATEMESHBUFFER
    raylib_name: UpdateMeshBuffer
    args: [int, int, string, int, int]
    ret: void
    category: 3d
    description: "Update mesh vertex data in GPU (pass mesh ID, index, data as string, dataSize, offset)"
    custom_body: |
      // TODO: Proper data handling

  - name: GETMESHBOUNDINGBOX
    raylib_name: GetMeshBoundingBox
    args: [int]
    ret: string
    category: 3d
    description: "Compute mesh bounding box limits (pass mesh ID)"
    custom_body: |
      ::BoundingBox box = ::GetMeshBoundingBox(rlreg::meshes.at(INT(0)));
      return Value::from_string(std::to_string(box.min.x) + "," + std::to_string(box.min.y) + "," + std::to_string(box.min.z) + "," + std::to_string(box.max.x) + "," + std::to_string(box.max.y) + "," + std::to_string(box.max.z));

  - name: GENMESHTANGENTS
    raylib_name: GenMeshTangents
    args: [int]
    ret: void
    category: 3d
    description: "Compute mesh tangents (pass mesh ID)"
    custom_body: |
      ::GenMeshTangents(&rlreg::meshes.at(INT(0)));

  - name: EXPORTMESH
    raylib_name: ExportMesh
    args: [int, string]
    ret: bool
    category: 3d
    description: "Export mesh data to file (pass mesh ID, fileName)"
    custom_body: |
      return Value::from_bool(::ExportMesh(rlreg::meshes.at(INT(0)), STR(1).c_str()));

  - name: EXPORTMESHASCODE
    raylib_name: ExportMeshAsCode
    args: [int, string]
    ret: bool
    category: 3d
    description: "Export mesh as code file (pass mesh ID, fileName)"
    custom_body: |
      return Value::from_bool(::ExportMeshAsCode(rlreg::meshes.at(INT(0)), STR(1).c_str()));

  - name: GENMESHHEMISPHERE
    raylib_name: GenMeshHemiSphere
    args: [float, int, int]
    ret: int
    category: 3d
    description: "Generate half-sphere mesh (radius, rings, slices)"
    custom_body: |
      ::Mesh mesh = ::GenMeshHemiSphere((float)FLOAT(0), INT(1), INT(2));
      int id = rlreg::next_mesh_id++;
      rlreg::meshes[id] = mesh;
      return Value::from_int(id);

  - name: GENMESHCONE
    raylib_name: GenMeshCone
    args: [float, float, int]
    ret: int
    category: 3d
    description: "Generate cone/pyramid mesh (radius, height, slices)"
    custom_body: |
      ::Mesh mesh = ::GenMeshCone((float)FLOAT(0), (float)FLOAT(1), INT(2));
      int id = rlreg::next_mesh_id++;
      rlreg::meshes[id] = mesh;
      return Value::from_int(id);

  # === MATERIAL FUNCTIONS ===
  - name: ISMATERIALVALID
    raylib_name: IsMaterialValid
    args: [int]
    ret: bool
    category: 3d
    description: "Check if material is valid (pass material ID)"
    custom_body: |
      return Value::from_bool(::IsMaterialValid(rlreg::materials.at(INT(0))));

  - name: SETMODELMESHMATERIAL
    raylib_name: SetModelMeshMaterial
    args: [int, int, int]
    ret: void
    category: 3d
    description: "Set material for a mesh (pass model ID, meshId, materialId)"
    custom_body: |
      ::SetModelMeshMaterial(&rlreg::models.at(INT(0)), INT(1), INT(2));

  # === COLLISION FUNCTIONS ===
  - name: CHECKCOLLISIONSPHERES
    raylib_name: CheckCollisionSpheres
    args: [float, float, float, float, float, float, float, float]
    ret: bool
    category: collision
    description: "Check collision between two spheres (center1X, center1Y, center1Z, radius1, center2X, center2Y, center2Z, radius2)"
    custom_body: |
      ::Vector3 center1{(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ::Vector3 center2{(float)FLOAT(4), (float)FLOAT(5), (float)FLOAT(6)};
      return Value::from_bool(::CheckCollisionSpheres(center1, (float)FLOAT(3), center2, (float)FLOAT(7)));

  - name: CHECKCOLLISIONBOXES
    raylib_name: CheckCollisionBoxes
    args: [float, float, float, float, float, float, float, float, float, float, float, float]
    ret: bool
    category: collision
    description: "Check collision between two bounding boxes (box1 minX, minY, minZ, maxX, maxY, maxZ, box2 minX, minY, minZ, maxX, maxY, maxZ)"
    custom_body: |
      ::BoundingBox box1;
      box1.min = {(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      box1.max = {(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::BoundingBox box2;
      box2.min = {(float)FLOAT(6), (float)FLOAT(7), (float)FLOAT(8)};
      box2.max = {(float)FLOAT(9), (float)FLOAT(10), (float)FLOAT(11)};
      return Value::from_bool(::CheckCollisionBoxes(box1, box2));

  - name: CHECKCOLLISIONBOXSPHERE
    raylib_name: CheckCollisionBoxSphere
    args: [float, float, float, float, float, float, float, float, float, float]
    ret: bool
    category: collision
    description: "Check collision between box and sphere (box minX, minY, minZ, maxX, maxY, maxZ, centerX, centerY, centerZ, radius)"
    custom_body: |
      ::BoundingBox box;
      box.min = {(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      box.max = {(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 center{(float)FLOAT(6), (float)FLOAT(7), (float)FLOAT(8)};
      return Value::from_bool(::CheckCollisionBoxSphere(box, center, (float)FLOAT(9)));

  - name: GETRAYCOLLISIONSPHERE
    raylib_name: GetRayCollisionSphere
    args: [float, float, float, float, float, float, float, float, float, float]
    ret: string
    category: collision
    description: "Get collision info between ray and sphere (ray posX, posY, posZ, dirX, dirY, dirZ, centerX, centerY, centerZ, radius)"
    custom_body: |
      ::Ray ray;
      ray.position = {(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ray.direction = {(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 center{(float)FLOAT(6), (float)FLOAT(7), (float)FLOAT(8)};
      ::RayCollision collision = ::GetRayCollisionSphere(ray, center, (float)FLOAT(9));
      if (collision.hit) {
        return Value::from_string(std::to_string(collision.point.x) + "," + std::to_string(collision.point.y) + "," + std::to_string(collision.point.z) + "," + std::to_string(collision.distance));
      }
      return Value::from_string("");

  - name: GETRAYCOLLISIONBOX
    raylib_name: GetRayCollisionBox
    args: [float, float, float, float, float, float, float, float, float, float, float, float]
    ret: string
    category: collision
    description: "Get collision info between ray and box (ray posX, posY, posZ, dirX, dirY, dirZ, box minX, minY, minZ, maxX, maxY, maxZ)"
    custom_body: |
      ::Ray ray;
      ray.position = {(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ray.direction = {(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::BoundingBox box;
      box.min = {(float)FLOAT(6), (float)FLOAT(7), (float)FLOAT(8)};
      box.max = {(float)FLOAT(9), (float)FLOAT(10), (float)FLOAT(11)};
      ::RayCollision collision = ::GetRayCollisionBox(ray, box);
      if (collision.hit) {
        return Value::from_string(std::to_string(collision.point.x) + "," + std::to_string(collision.point.y) + "," + std::to_string(collision.point.z) + "," + std::to_string(collision.distance));
      }
      return Value::from_string("");

  - name: GETRAYCOLLISIONTRIANGLE
    raylib_name: GetRayCollisionTriangle
    args: [float, float, float, float, float, float, float, float, float, float, float, float, float, float, float]
    ret: string
    category: collision
    description: "Get collision info between ray and triangle (ray posX, posY, posZ, dirX, dirY, dirZ, p1X, p1Y, p1Z, p2X, p2Y, p2Z, p3X, p3Y, p3Z)"
    custom_body: |
      ::Ray ray;
      ray.position = {(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ray.direction = {(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 p1{(float)FLOAT(6), (float)FLOAT(7), (float)FLOAT(8)};
      ::Vector3 p2{(float)FLOAT(9), (float)FLOAT(10), (float)FLOAT(11)};
      ::Vector3 p3{(float)FLOAT(12), (float)FLOAT(13), (float)FLOAT(14)};
      ::RayCollision collision = ::GetRayCollisionTriangle(ray, p1, p2, p3);
      if (collision.hit) {
        return Value::from_string(std::to_string(collision.point.x) + "," + std::to_string(collision.point.y) + "," + std::to_string(collision.point.z) + "," + std::to_string(collision.distance));
      }
      return Value::from_string("");

  - name: GETRAYCOLLISIONQUAD
    raylib_name: GetRayCollisionQuad
    args: [float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float, float]
    ret: string
    category: collision
    description: "Get collision info between ray and quad (ray posX, posY, posZ, dirX, dirY, dirZ, p1X, p1Y, p1Z, p2X, p2Y, p2Z, p3X, p3Y, p3Z, p4X, p4Y, p4Z)"
    custom_body: |
      ::Ray ray;
      ray.position = {(float)FLOAT(0), (float)FLOAT(1), (float)FLOAT(2)};
      ray.direction = {(float)FLOAT(3), (float)FLOAT(4), (float)FLOAT(5)};
      ::Vector3 p1{(float)FLOAT(6), (float)FLOAT(7), (float)FLOAT(8)};
      ::Vector3 p2{(float)FLOAT(9), (float)FLOAT(10), (float)FLOAT(11)};
      ::Vector3 p3{(float)FLOAT(12), (float)FLOAT(13), (float)FLOAT(14)};
      ::Vector3 p4{(float)FLOAT(15), (float)FLOAT(16), (float)FLOAT(17)};
      ::RayCollision collision = ::GetRayCollisionQuad(ray, p1, p2, p3, p4);
      if (collision.hit) {
        return Value::from_string(std::to_string(collision.point.x) + "," + std::to_string(collision.point.y) + "," + std::to_string(collision.point.z) + "," + std::to_string(collision.distance));
      }
      return Value::from_string("");
